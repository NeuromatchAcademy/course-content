
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tutorial 1: Decoding Neural Responses &#8212; Neuromatch Computational Neuroscience</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Tutorial 2: Convolutional Neural Networks" href="W2D1_Tutorial2.html" />
    <link rel="prev" title="Intro" href="../W2D1_Intro.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
      <img src="../../../_static/nma-logo-square-4xp.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Neuromatch Computational Neuroscience</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../intro.html">
   Introduction
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Pre-reqs Refresher
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W0D1_PythonWorkshop1/chapter_title.html">
   Python Workshop 1 (W0D1)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D1_PythonWorkshop1/student/W0D1_Tutorial1.html">
     Tutorial: LIF Neuron - Part I
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W0D2_PythonWorkshop2/chapter_title.html">
   Python Workshop 2 (W0D2)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D2_PythonWorkshop2/student/W0D2_Tutorial1.html">
     Tutorial 1: LIF Neuron Part II
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W0D3_LinearAlgebra/chapter_title.html">
   Linear Algebra (W0D3)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D3_LinearAlgebra/student/W0D3_Tutorial1.html">
     Tutorial 1: Vectors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D3_LinearAlgebra/student/W0D3_Tutorial2.html">
     Tutorial 2: Matrices
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D3_LinearAlgebra/student/W0D3_Tutorial3.html">
     Bonus Tutorial: Discrete Dynamical Systems
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W0D4_Calculus/chapter_title.html">
   Calculus (W0D4)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D4_Calculus/student/W0D4_Tutorial1.html">
     Tutorial 1: Basics of Differential and Integral Calculus
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D4_Calculus/student/W0D4_Tutorial2.html">
     Tutorial 2: Differential Equations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D4_Calculus/student/W0D4_Tutorial3.html">
     Tutorial 3: Numerical Methods
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W0D5_Statistics/chapter_title.html">
   Statistics (W0D5)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D5_Statistics/student/W0D5_Tutorial1.html">
     Neuromatch Academy: Precourse Week, Day 5, Tutorial 1
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W0D5_Statistics/student/W0D5_Tutorial2.html">
     Tutorial 2: Statistical Inference
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Intro to Modeling
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W1D1_ModelTypes/chapter_title.html">
   Model Types (W1D1)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D1_ModelTypes/W1D1_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D1_ModelTypes/student/W1D1_Tutorial1.html">
     Tutorial 1: “What” models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D1_ModelTypes/student/W1D1_Tutorial2.html">
     Tutorial 2: “How” models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D1_ModelTypes/student/W1D1_Tutorial3.html">
     Tutorial 3: “Why” models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D1_ModelTypes/W1D1_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D1_ModelTypes/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W1D2_ModelingPractice/chapter_title.html">
   Modeling Practice (W1D2)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D2_ModelingPractice/W1D2_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D2_ModelingPractice/student/W1D2_Tutorial1.html">
     Tutorial: Framing the Question
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D2_ModelingPractice/W1D2_Outro.html">
     Outro
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Machine Learning
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W1D3_ModelFitting/chapter_title.html">
   Model Fitting (W1D3)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/W1D3_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/student/W1D3_Tutorial1.html">
     Tutorial 1: Linear regression with MSE
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/student/W1D3_Tutorial2.html">
     Tutorial 2: Linear regression with MLE
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/student/W1D3_Tutorial3.html">
     Tutorial 3: Confidence intervals and bootstrapping
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/student/W1D3_Tutorial4.html">
     Tutorial 4: Multiple linear regression and polynomial regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/student/W1D3_Tutorial5.html">
     Tutorial 5: Model Selection: Bias-variance trade-off
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/student/W1D3_Tutorial6.html">
     Tutorial 6: Model Selection: Cross-validation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/W1D3_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D3_ModelFitting/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W1D4_GeneralizedLinearModels/chapter_title.html">
   Generalized Linear Models (W1D4)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D4_GeneralizedLinearModels/W1D4_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D4_GeneralizedLinearModels/student/W1D4_Tutorial1.html">
     Tutorial 1: GLMs for Encoding
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D4_GeneralizedLinearModels/student/W1D4_Tutorial2.html">
     Tutorial 2: Classifiers and regularizers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D4_GeneralizedLinearModels/W1D4_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D4_GeneralizedLinearModels/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W1D5_DimensionalityReduction/chapter_title.html">
   Dimensionality Reduction (W1D5)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/W1D5_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/student/W1D5_Tutorial1.html">
     Tutorial 1: Geometric view of data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/student/W1D5_Tutorial2.html">
     Tutorial 2: Principal Component Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/student/W1D5_Tutorial3.html">
     Tutorial 3: Dimensionality Reduction &amp; Reconstruction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/student/W1D5_Tutorial4.html">
     Tutorial 4:  Nonlinear Dimensionality Reduction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/W1D5_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W1D5_DimensionalityReduction/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../chapter_title.html">
   Deep Learning (W2D1)
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="../W2D1_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Tutorial 1: Decoding Neural Responses
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="W2D1_Tutorial2.html">
     Tutorial 2: Convolutional Neural Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="W2D1_Tutorial3.html">
     Tutorial 2: Building and Evaluating Normative Encoding Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../W2D1_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Dynamical Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W2D2_LinearSystems/chapter_title.html">
   Linear Systems (W2D2)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/W2D2_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/student/W2D2_Tutorial1.html">
     Tutorial 1: Linear dynamical systems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/student/W2D2_Tutorial2.html">
     Tutorial 2: Markov Processes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/student/W2D2_Tutorial3.html">
     Tutorial 3: Combining determinism and stochasticity
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/student/W2D2_Tutorial4.html">
     Tutorial 4: Autoregressive models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/W2D2_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D2_LinearSystems/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/chapter_title.html">
   Biological Neuron Models (W2D3)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/W2D3_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/student/W2D3_Tutorial1.html">
     Tutorial 1: The Leaky Integrate-and-Fire (LIF) Neuron Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/student/W2D3_Tutorial2.html">
     Tutorial 2: Effects of Input Correlation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/student/W2D3_Tutorial3.html">
     Tutorial 3: Synaptic transmission - Models of static and dynamic synapses
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/student/W2D3_Tutorial4.html">
     Tutorial 4: Spike-timing dependent plasticity (STDP)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/W2D3_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D3_BiologicalNeuronModels/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W2D4_DynamicNetworks/chapter_title.html">
   Dynamic Networks (W2D4)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D4_DynamicNetworks/W2D4_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D4_DynamicNetworks/student/W2D4_Tutorial1.html">
     Tutorial 1: Neural Rate Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D4_DynamicNetworks/student/W2D4_Tutorial2.html">
     Tutorial 2: Wilson-Cowan Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D4_DynamicNetworks/W2D4_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W2D4_DynamicNetworks/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Stochastic Processes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W3D1_BayesianDecisions/chapter_title.html">
   Bayesian Decisions (W3D1)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
  <label for="toctree-checkbox-15">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D1_BayesianDecisions/W3D1_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D1_BayesianDecisions/student/W3D1_Tutorial1.html">
     Tutorial 1: Bayes with a binary hidden state
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D1_BayesianDecisions/student/W3D1_Tutorial2.html">
     Tutorial 2: Bayesian inference and decisions with continuous hidden state
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D1_BayesianDecisions/student/W3D1_Tutorial3.html">
     Bonus Tutorial:Fitting to data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D1_BayesianDecisions/W3D1_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D1_BayesianDecisions/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W3D2_HiddenDynamics/chapter_title.html">
   Hidden Dynamics (W3D2)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
  <label for="toctree-checkbox-16">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/W3D2_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/student/W3D2_Tutorial1.html">
     Tutorial 1: Sequential Probability Ratio Test
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/student/W3D2_Tutorial2.html">
     Tutorial 2: Hidden Markov Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/student/W3D2_Tutorial3.html">
     Tutorial 3: 1D Kalman Filter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/student/W3D2_Tutorial4.html">
     Tutorial 4: 2D Kalman Filter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/W3D2_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D2_HiddenDynamics/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W3D3_OptimalControl/chapter_title.html">
   Optimal Control (W3D3)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
  <label for="toctree-checkbox-17">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D3_OptimalControl/W3D3_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D3_OptimalControl/student/W3D3_Tutorial1.html">
     Tutorial 1: Optimal Control for Discrete States
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D3_OptimalControl/student/W3D3_Tutorial2.html">
     Tutorial 2: Optimal Control for Continuous State
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D3_OptimalControl/W3D3_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D3_OptimalControl/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W3D4_ReinforcementLearning/chapter_title.html">
   Reinforcement Learning (W3D4)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/>
  <label for="toctree-checkbox-18">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/W3D4_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/student/W3D4_Tutorial1.html">
     Tutorial 1: Learning to Predict
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/student/W3D4_Tutorial2.html">
     Tutorial 2: Learning to Act: Multi-Armed Bandits
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/student/W3D4_Tutorial3.html">
     Tutorial 3: Learning to Act: Q-Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/student/W3D4_Tutorial4.html">
     Tutorial 4: From Reinforcement Learning to Planning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/W3D4_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D4_ReinforcementLearning/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../W3D5_NetworkCausality/chapter_title.html">
   Network Causality (W3D5)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/>
  <label for="toctree-checkbox-19">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/W3D5_Intro.html">
     Intro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/student/W3D5_Tutorial1.html">
     Tutorial 1: Interventions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/student/W3D5_Tutorial2.html">
     Tutorial 2: Correlations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/student/W3D5_Tutorial3.html">
     Tutorial 3: Simultaneous fitting/regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/student/W3D5_Tutorial4.html">
     Tutorial 4: Instrumental Variables
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/W3D5_Outro.html">
     Outro
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../W3D5_NetworkCausality/further_reading.html">
     Suggested further readings
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/tutorials/W2D1_DeepLearning/student/W2D1_Tutorial1.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/NeuromatchAcademy/course_content/blob/master/book/tutorials/W2D1_DeepLearning/student/W2D1_Tutorial1.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../../../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Tutorial 1: Decoding Neural Responses
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tutorial-objectives">
   Tutorial Objectives
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#setup">
   Setup
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#section-1-load-and-visualize-data">
   Section 1: Load and visualize data
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#section-2-deep-feed-forward-networks-in-pytorch">
   Section 2: Deep feed-forward networks in
   <em>
    pytorch
   </em>
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#section-2-1-introduction-to-pytorch">
     Section 2.1: Introduction to PyTorch
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#section-2-2-activation-functions">
     Section 2.2: Activation functions
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#coding-exercise-2-2-nonlinear-activations">
       Coding Exercise 2.2: Nonlinear Activations
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#section-3-loss-functions-and-gradient-descent">
   Section 3: Loss functions and gradient descent
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#section-3-1-loss-functions">
     Section 3.1: Loss functions
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#coding-exercise-3-1-computing-mse">
       Coding Exercise 3.1: Computing MSE
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#section-3-2-optimization-with-gradient-descent">
     Section 3.2: Optimization with gradient descent
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#coding-exercise-3-2-gradient-descent-in-pytorch">
       Coding Exercise 3.2: Gradient descent in PyTorch
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#section-4-investigating-model-and-evaluating-performance">
   Section 4: Investigating model and evaluating performance
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#section-4-1-peering-inside-the-decoding-model">
     Section 4.1: Peering inside the decoding model
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#coding-exercise-4-1-visualizing-weights">
       Coding Exercise 4.1: Visualizing weights
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#think-4-interpreting-weights">
       Think! 4: Interpreting weights
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#section-4-2-generalization-performance-with-test-data">
     Section 4.2: Generalization performance with test data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary">
   Summary
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bonus">
   Bonus
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bonus-section-1-neural-network-depth-width-and-expressivity">
     Bonus Section 1: Neural network
     <em>
      depth
     </em>
     ,
     <em>
      width
     </em>
     and
     <em>
      expressivity
     </em>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bonus-section-2-gradient-descent">
     Bonus Section 2: Gradient descent
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bonus-section-2-1-gradient-descent-equations">
       Bonus Section 2.1: Gradient descent equations
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bonus-section-2-2-stochastic-gradient-descent-sgd-vs-gradient-descent-gd">
       Bonus Section 2.2:
       <em>
        Stochastic
       </em>
       gradient descent (SGD) vs. gradient descent (GD)
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bonus-section-3-evaluating-improving-models">
     Bonus Section 3: Evaluating &amp; improving models
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bonus-section-3-1-model-criticism">
       Bonus Section 3.1: Model criticism
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#bonus-think-3-1-delving-into-error-problems">
         Bonus Think! 3.1: Delving into error problems
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bonus-section-3-2-improving-the-loss-function">
       Bonus Section 3.2: Improving the loss function
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#bonus-coding-exercise-3-2-a-new-loss-function">
         Bonus Coding Exercise 3.2: A new loss function
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bonus-section-3-3-regularization">
       Bonus Section 3.3: Regularization
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#bonus-coding-exercise-3-3-add-regularization-to-training">
         Bonus Coding Exercise 3.3: Add regularization to training
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <p><a href="https://colab.research.google.com/github/NeuromatchAcademy/course-content/blob/master/tutorials/W2D1_DeepLearning/student/W2D1_Tutorial1.ipynb" target="_blank"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg"/></a></p>
<div class="section" id="tutorial-1-decoding-neural-responses">
<h1>Tutorial 1: Decoding Neural Responses<a class="headerlink" href="#tutorial-1-decoding-neural-responses" title="Permalink to this headline">¶</a></h1>
<p><strong>Week 2, Day 1: Deep Learning</strong></p>
<p><strong>By Neuromatch Academy</strong></p>
<p><strong>Content creators</strong>: Jorge A. Menendez, Carsen Stringer</p>
<p><strong>Content reviewers</strong>: Roozbeh Farhoodi,  Madineh Sarvestani, Kshitij Dwivedi, Spiros Chavlis, Ella Batty, Michael Waskom</p>
</div>
<hr class="docutils" />
<div class="section" id="tutorial-objectives">
<h1>Tutorial Objectives<a class="headerlink" href="#tutorial-objectives" title="Permalink to this headline">¶</a></h1>
<p>In this tutorial, we’ll use deep learning to decode stimulus information from the responses of sensory neurons. Specifically, we’ll look at the activity of ~20,000 neurons in mouse primary visual cortex responding to oriented gratings recorded in <a class="reference external" href="https://www.biorxiv.org/content/10.1101/679324v2.abstract">this study</a>. Our task will be to decode the orientation of the presented stimulus from the responses of the whole population of neurons. We could do this in a number of ways, but here we’ll use deep learning. Deep learning is particularly well-suited to this problem for a number of reasons:</p>
<ul class="simple">
<li><p>The data are very high-dimensional: the neural response to a stimulus is a ~20,000 dimensional vector. Many machine learning techniques fail in such high dimensions, but deep learning actually thrives in this regime, as long as you have enough data (which we do here!).</p></li>
<li><p>As you’ll be able to see below, different neurons can respond quite differently to stimuli. This complex pattern of responses will, therefore, require non-linear methods to be decoded, which we can easily do with non-linear activation functions in deep networks.</p></li>
<li><p>Deep learning architectures are highly flexible, meaning we can easily adapt the architecture of our decoding model to optimize decoding. Here, we’ll focus on a single architecture, but you’ll see that it can easily be modified with few changes to the code.</p></li>
</ul>
<p>More concretely, our goal will be learn how to:</p>
<ul class="simple">
<li><p>Build a deep feed-forward network using PyTorch</p></li>
<li><p>Evaluate the network’s outputs using PyTorch built-in loss functions</p></li>
<li><p>Compute gradients of the loss with respect to each parameter of the network using automatic differentiation</p></li>
<li><p>Implement gradient descent to optimize the network’s parameters</p></li>
<li><p>(Bonus) Learn how to regularize the optimization</p></li>
</ul>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Video 1: Decoding from neural data using feed-forward networks in pytorch</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">YouTubeVideo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;SlrbMvvBOzM&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">854</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">480</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Video available at https://youtu.be/&quot;</span> <span class="o">+</span> <span class="n">video</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="n">video</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="setup">
<h1>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">optim</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Data retrieval and loading</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">requests</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;W3D4_stringer_oribinned1.npz&quot;</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://osf.io/683xc/download&quot;</span>
<span class="n">expected_md5</span> <span class="o">=</span> <span class="s2">&quot;436599dfd8ebe6019f066c38aed20580&quot;</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
  <span class="k">except</span> <span class="n">requests</span><span class="o">.</span><span class="n">ConnectionError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!!! Failed to download data !!!&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span> <span class="o">!=</span> <span class="n">requests</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">ok</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!!! Failed to download data !!!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span> <span class="o">!=</span> <span class="n">expected_md5</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!!! Data download appears corrupted !!!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
        <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Figure Settings</span>
<span class="o">%</span><span class="k">config</span> InlineBackend.figure_format = &#39;retina&#39;
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;https://raw.githubusercontent.com/NeuromatchAcademy/course-content/master/nma.mplstyle&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Plotting Functions</span>

<span class="k">def</span> <span class="nf">plot_data_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Visualize data matrix of neural responses using a heatmap</span>

<span class="sd">  Args:</span>
<span class="sd">    X (torch.Tensor or np.ndarray): matrix of neural responses to visualize</span>
<span class="sd">        with a heatmap</span>
<span class="sd">    ax (matplotlib axes): where to plot</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">pink</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span>
  <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;normalized neural response&#39;</span><span class="p">)</span>

  <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
  <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
  <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

<span class="k">def</span> <span class="nf">plot_decoded_results</span><span class="p">(</span><span class="n">train_loss</span><span class="p">,</span> <span class="n">test_loss</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">,</span> <span class="n">predicted_test_labels</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Plot decoding results in the form of network training loss and test predictions</span>

<span class="sd">  Args:</span>
<span class="sd">    train_loss (list): training error over iterations</span>
<span class="sd">    test_labels (torch.Tensor): n_test x 1 tensor with orientations of the</span>
<span class="sd">      stimuli corresponding to each row of train_data, in radians</span>
<span class="sd">    predicted_test_labels (torch.Tensor): n_test x 1 tensor with predicted orientations of the</span>
<span class="sd">      stimuli from decoding neural network</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># Plot results</span>
  <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

  <span class="c1"># Plot the training loss over iterations of GD</span>
  <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">train_loss</span><span class="p">)</span>
  <span class="c1"># Plot the testing loss over iterations of GD</span>
  <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">test_loss</span><span class="p">)</span>
  <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;train loss&#39;</span><span class="p">,</span> <span class="s1">&#39;test loss&#39;</span><span class="p">])</span>

  <span class="c1"># Plot true stimulus orientation vs. predicted class</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">stimuli_test</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">predicted_test_labels</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>

  <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
  <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
  <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iterations of gradient descent&#39;</span><span class="p">)</span>
  <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;negative log likelihood&#39;</span><span class="p">)</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;true stimulus orientation ($^o$)&#39;</span><span class="p">)</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;decoded orientation bin&#39;</span><span class="p">)</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">n_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_classes</span><span class="p">))</span>
  <span class="n">class_bins</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">n_classes</span><span class="si">:</span><span class="s1"> .0f</span><span class="si">}</span><span class="s1">$^o$ - </span><span class="si">{</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">n_classes</span><span class="si">:</span><span class="s1"> .0f</span><span class="si">}</span><span class="s1">$^o$&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">)]</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">class_bins</span><span class="p">);</span>

  <span class="c1"># Draw bin edges as vertical lines</span>
  <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ax2</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">())</span>  <span class="c1"># fix y-axis limits</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">n_classes</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">n_classes</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">lower</span><span class="p">,</span> <span class="n">lower</span><span class="p">],</span> <span class="n">ax2</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">(),</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;0.7&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">upper</span><span class="p">,</span> <span class="n">upper</span><span class="p">],</span> <span class="n">ax2</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">(),</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;0.7&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

  <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Helper Functions</span>

<span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">data_name</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span> <span class="n">bin_width</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Load mouse V1 data from Stringer et al. (2019)</span>

<span class="sd">  Data from study reported in this preprint:</span>
<span class="sd">  https://www.biorxiv.org/content/10.1101/679324v2.abstract</span>

<span class="sd">  These data comprise time-averaged responses of ~20,000 neurons</span>
<span class="sd">  to ~4,000 stimulus gratings of different orientations, recorded</span>
<span class="sd">  through Calcium imaging. The responses have been normalized by</span>
<span class="sd">  spontaneous levels of activity and then z-scored over stimuli, so</span>
<span class="sd">  expect negative numbers. They have also been binned and averaged</span>
<span class="sd">  to each degree of orientation.</span>

<span class="sd">  This function returns the relevant data (neural responses and</span>
<span class="sd">  stimulus orientations) in a torch.Tensor of data type torch.float32</span>
<span class="sd">  in order to match the default data type for nn.Parameters in</span>
<span class="sd">  Google Colab.</span>

<span class="sd">  This function will actually average responses to stimuli with orientations</span>
<span class="sd">  falling within bins specified by the bin_width argument. This helps</span>
<span class="sd">  produce individual neural &quot;responses&quot; with smoother and more</span>
<span class="sd">  interpretable tuning curves.</span>

<span class="sd">  Args:</span>
<span class="sd">    bin_width (float): size of stimulus bins over which to average neural</span>
<span class="sd">      responses</span>

<span class="sd">  Returns:</span>
<span class="sd">    resp (torch.Tensor): n_stimuli x n_neurons matrix of neural responses,</span>
<span class="sd">        each row contains the responses of each neuron to a given stimulus.</span>
<span class="sd">        As mentioned above, neural &quot;response&quot; is actually an average over</span>
<span class="sd">        responses to stimuli with similar angles falling within specified bins.</span>
<span class="sd">    stimuli: (torch.Tensor): n_stimuli x 1 column vector with orientation</span>
<span class="sd">        of each stimulus, in degrees. This is actually the mean orientation</span>
<span class="sd">        of all stimuli in each bin.</span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">dobj</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">dobj</span><span class="p">)</span>
  <span class="n">resp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;resp&#39;</span><span class="p">]</span>
  <span class="n">stimuli</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;stimuli&#39;</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">bin_width</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># Bin neural responses and stimuli</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">stimuli</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">))</span>
    <span class="n">stimuli_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stimuli</span><span class="p">[</span><span class="n">bins</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bins</span><span class="p">)])</span>
    <span class="n">resp_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">resp</span><span class="p">[</span><span class="n">bins</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bins</span><span class="p">)])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resp_binned</span> <span class="o">=</span> <span class="n">resp</span>
    <span class="n">stimuli_binned</span> <span class="o">=</span> <span class="n">stimuli</span>

  <span class="c1"># Return as torch.Tensor</span>
  <span class="n">resp_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">resp_binned</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
  <span class="n">stimuli_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">stimuli_binned</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># add singleton dimension to make a column vector</span>

  <span class="k">return</span> <span class="n">resp_tensor</span><span class="p">,</span> <span class="n">stimuli_tensor</span>


<span class="k">def</span> <span class="nf">identityLine</span><span class="p">():</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Plot the identity line y=x</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
  <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">(),</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()])</span>
  <span class="n">minval</span> <span class="o">=</span> <span class="n">lims</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
  <span class="n">maxval</span> <span class="o">=</span> <span class="n">lims</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
  <span class="n">equal_lims</span> <span class="o">=</span> <span class="p">[</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">]</span>
  <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">equal_lims</span><span class="p">)</span>
  <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">equal_lims</span><span class="p">)</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">],</span> <span class="p">[</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;0.7&quot;</span><span class="p">)</span>
  <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">n_stim</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Return n_stim randomly drawn stimuli/resp pairs</span>

<span class="sd">  Args:</span>
<span class="sd">    n_stim (scalar): number of stimuli to draw</span>
<span class="sd">    resp (torch.Tensor):</span>
<span class="sd">    train_data (torch.Tensor): n_train x n_neurons tensor with neural</span>
<span class="sd">      responses to train on</span>
<span class="sd">    train_labels (torch.Tensor): n_train x 1 tensor with orientations of the</span>
<span class="sd">      stimuli corresponding to each row of train_data, in radians</span>

<span class="sd">  Returns:</span>
<span class="sd">    (torch.Tensor, torch.Tensor): n_stim x n_neurons tensor of neural responses and n_stim x 1 of orientations respectively</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">n_stimuli</span> <span class="o">=</span> <span class="n">train_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">istim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_stimuli</span><span class="p">,</span> <span class="n">n_stim</span><span class="p">)</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">train_data</span><span class="p">[</span><span class="n">istim</span><span class="p">]</span>  <span class="c1"># neural responses to this stimulus</span>
  <span class="n">ori</span> <span class="o">=</span> <span class="n">train_labels</span><span class="p">[</span><span class="n">istim</span><span class="p">]</span>  <span class="c1"># true stimulus orientation</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">ori</span>

<span class="k">def</span> <span class="nf">stimulus_class</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Get stimulus class from stimulus orientation</span>

<span class="sd">  Args:</span>
<span class="sd">    ori (torch.Tensor): orientations of stimuli to return classes for</span>
<span class="sd">    n_classes (int): total number of classes</span>

<span class="sd">  Returns:</span>
<span class="sd">    torch.Tensor: 1D tensor with the classes for each stimulus</span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">n_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">bins</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># minus 1 to accomodate Python indexing</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="section-1-load-and-visualize-data">
<h1>Section 1: Load and visualize data<a class="headerlink" href="#section-1-load-and-visualize-data" title="Permalink to this headline">¶</a></h1>
<p>In the next cell, we have provided code to load the data and plot the matrix of neural responses.</p>
<p>Next to it, we plot the tuning curves of three randomly selected neurons.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title</span>

<span class="c1">#@markdown Execute this cell to load and visualize data</span>

<span class="c1"># Load data</span>
<span class="n">resp_all</span><span class="p">,</span> <span class="n">stimuli_all</span> <span class="o">=</span> <span class="n">load_data</span><span class="p">()</span>  <span class="c1"># argument to this function specifies bin width</span>
<span class="n">n_stimuli</span><span class="p">,</span> <span class="n">n_neurons</span> <span class="o">=</span> <span class="n">resp_all</span><span class="o">.</span><span class="n">shape</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_neurons</span><span class="si">}</span><span class="s1"> neurons in response to </span><span class="si">{</span><span class="n">n_stimuli</span><span class="si">}</span><span class="s1"> stimuli&#39;</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Visualize data matrix</span>
<span class="n">plot_data_matrix</span><span class="p">(</span><span class="n">resp_all</span><span class="p">[:</span><span class="mi">100</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>  <span class="c1"># plot responses of first 100 neurons</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;stimulus&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;neuron&#39;</span><span class="p">)</span>

<span class="c1"># Plot tuning curves of three random neurons</span>
<span class="n">ineurons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># pick three random neurons</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">stimuli_all</span><span class="p">,</span> <span class="n">resp_all</span><span class="p">[:,</span> <span class="n">ineurons</span><span class="p">])</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;stimulus orientation ($^o$)&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;neural response&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We will split our data into a training set and test set. In particular, we will have a training set of orientations (<code class="docutils literal notranslate"><span class="pre">stimuli_train</span></code>) and the corresponding responses (<code class="docutils literal notranslate"><span class="pre">resp_train</span></code>). Our testing set will have held-out orientations (<code class="docutils literal notranslate"><span class="pre">stimuli_test</span></code>) and the corresponding responses (<code class="docutils literal notranslate"><span class="pre">resp_test</span></code>).</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title</span>
<span class="c1">#@markdown Execute this cell to split into training and test sets</span>

<span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Split data into training set and testing set</span>
<span class="n">n_train</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.6</span> <span class="o">*</span> <span class="n">n_stimuli</span><span class="p">)</span>  <span class="c1"># use 60% of all data for training set</span>
<span class="n">ishuffle</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">n_stimuli</span><span class="p">)</span>
<span class="n">itrain</span> <span class="o">=</span> <span class="n">ishuffle</span><span class="p">[:</span><span class="n">n_train</span><span class="p">]</span>  <span class="c1"># indices of data samples to include in training set</span>
<span class="n">itest</span> <span class="o">=</span> <span class="n">ishuffle</span><span class="p">[</span><span class="n">n_train</span><span class="p">:]</span>  <span class="c1"># indices of data samples to include in testing set</span>
<span class="n">stimuli_test</span> <span class="o">=</span> <span class="n">stimuli_all</span><span class="p">[</span><span class="n">itest</span><span class="p">]</span>
<span class="n">resp_test</span> <span class="o">=</span> <span class="n">resp_all</span><span class="p">[</span><span class="n">itest</span><span class="p">]</span>
<span class="n">stimuli_train</span> <span class="o">=</span> <span class="n">stimuli_all</span><span class="p">[</span><span class="n">itrain</span><span class="p">]</span>
<span class="n">resp_train</span> <span class="o">=</span> <span class="n">resp_all</span><span class="p">[</span><span class="n">itrain</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="section-2-deep-feed-forward-networks-in-pytorch">
<h1>Section 2: Deep feed-forward networks in <em>pytorch</em><a class="headerlink" href="#section-2-deep-feed-forward-networks-in-pytorch" title="Permalink to this headline">¶</a></h1>
<p>We’ll now build a simple deep neural network that takes as input a vector of neural responses and outputs a single number representing the decoded stimulus orientation.</p>
<p>To keep things simple, we’ll build a deep network with <strong>one</strong> hidden layer that is <strong>fully connected</strong>, which means <em>every</em> output is a weighted sum of <em>every</em> input. See Bonus Section 1 for a deeper discussion of what this choice entails, and when one might want to use deeper/shallower and wider/narrower architectures.</p>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{r}^{(n)} = \begin{bmatrix} r_1^{(n)} &amp; r_2^{(n)} &amp; \ldots &amp; r_N^{(n)} \end{bmatrix}^T\)</span> denote the vector of neural responses (of neurons <span class="math notranslate nohighlight">\(1, \ldots, N\)</span>) to the <span class="math notranslate nohighlight">\(n\)</span>th stimulus. The network we will use is described by the following set of equations:</p>
<div class="amsmath math notranslate nohighlight" id="equation-7dc718da-3494-4019-a1c4-e99449615943">
<span class="eqno">(84)<a class="headerlink" href="#equation-7dc718da-3494-4019-a1c4-e99449615943" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \mathbf{h}^{(n)} &amp;= \mathbf{W}^{in} \mathbf{r}^{(n)} + \mathbf{b}^{in}, &amp;&amp; [\mathbf{W}^{in}: M \times N], \\
    y^{(n)} &amp;= \mathbf{W}^{out} \mathbf{h}^{(n)} + \mathbf{b}^{out},  &amp;&amp; [\mathbf{W}^{out}: 1 \times M],
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(y^{(n)}\)</span> denotes the scalar output of the network: the decoded orientation of the <span class="math notranslate nohighlight">\(n\)</span>th stimulus.</p>
<p>The <span class="math notranslate nohighlight">\(M\)</span>-dimensional vector <span class="math notranslate nohighlight">\(\mathbf{h}^{(n)}\)</span> denotes the activations of the <strong>hidden layer</strong> of the network. The blue components of this diagram denote the <strong>parameters</strong> of the network, which we will later optimize with gradient descent. These include all the weights and biases <span class="math notranslate nohighlight">\(\mathbf{W}^{in}, \mathbf{b}^{in}, \mathbf{W}^{out}, \mathbf{b}^{out}\)</span>.</p>
<p align="center">
  <img src="https://github.com/NeuromatchAcademy/course-content/blob/master/tutorials/static/one-layer-network.png?raw=true" width="450" />
</p>
<div class="section" id="section-2-1-introduction-to-pytorch">
<h2>Section 2.1: Introduction to PyTorch<a class="headerlink" href="#section-2-1-introduction-to-pytorch" title="Permalink to this headline">¶</a></h2>
<p>Here, we’ll use the <strong>PyTorch</strong> package to build, run, and train deep networks of this form in Python. There are two core components to the PyTorch package:</p>
<ol class="simple">
<li><p>The first is the <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code> data type used in PyTorch. <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>’s are effectively just like a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> arrays, except that they have some important attributes and methods needed for automatic differentiation (to be discussed below). They also come along with infrastructure for easily storing and computing with them on GPU’s, a capability we won’t touch on here but which can be really useful in practice.</p></li>
<li><p>The second core ingredient is the PyTorch <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class. This is the class we’ll use for constructing deep networks, so that we can then easily train them using built-in PyTorch functions. Keep in my mind that <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> classes can actually be used to build, run, and train any model – not just deep networks!</p></li>
</ol>
<p>The next cell contains code for building the deep network we defined above using the <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class. It contains three key ingredients:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method to initialize its parameters, like in any other Python class. In this case, it takes two arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n_inputs</span></code>: the number of input units. This should always be set to the number of neurons whose activities are being decoded (i.e. the dimensionality of the input to the network).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_hidden</span></code>: the number of hidden units. This is a parameter that we are free to vary in deciding how to build our network. See Bonus Section 1 for a discussion of how this architectural choice affects the computations the network can perform.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">nn.Linear</span></code> modules, which are built-in PyTorch classes containing all the weights and biases for a given network layer (documentation <a class="reference external" href="https://pytorch.org/docs/master/generated/torch.nn.Linear.html">here</a>). This class takes two arguments to initialize:</p>
<ul class="simple">
<li><p># of inputs to that layer</p></li>
<li><p># of outputs from that layer</p></li>
</ul>
<p>For the input layer, for example, we have:</p>
<ul class="simple">
<li><p># of inputs = # of neurons whose responses are to be decoded (<span class="math notranslate nohighlight">\(N\)</span>, specified by <code class="docutils literal notranslate"><span class="pre">n_inputs</span></code>)</p></li>
<li><p># of outputs = # of hidden layer units (<span class="math notranslate nohighlight">\(M\)</span>, specified by <code class="docutils literal notranslate"><span class="pre">n_hidden</span></code>)</p></li>
</ul>
<p>PyTorch will initialize all weights and biases randomly.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">forward()</span></code> method, which takes as argument an input to the network and returns the network output. In our case, this comprises computing the output <span class="math notranslate nohighlight">\(y\)</span> from a given input <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> using the above two equations. See the next cell for code implementing this computation using the built-in PyTorch <code class="docutils literal notranslate"><span class="pre">nn.Linear</span></code> classes.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DeepNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Deep Network with one hidden layer</span>

<span class="sd">  Args:</span>
<span class="sd">    n_inputs (int): number of input units</span>
<span class="sd">    n_hidden (int): number of units in hidden layer</span>

<span class="sd">  Attributes:</span>
<span class="sd">    in_layer (nn.Linear): weights and biases of input layer</span>
<span class="sd">    out_layer (nn.Linear): weights and biases of output layer</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># needed to invoke the properties of the parent class nn.Module</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">in_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">)</span> <span class="c1"># neural activity --&gt; hidden units</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">out_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_hidden</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># hidden units --&gt; output</span>

  <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode stimulus orientation from neural responses</span>

<span class="sd">    Args:</span>
<span class="sd">      r (torch.Tensor): vector of neural responses to decode, must be of</span>
<span class="sd">        length n_inputs. Can also be a tensor of shape n_stimuli x n_inputs,</span>
<span class="sd">        containing n_stimuli vectors of neural responses</span>

<span class="sd">    Returns:</span>
<span class="sd">      torch.Tensor: network outputs for each input provided in r. If</span>
<span class="sd">        r is a vector, then y is a 1D tensor of length 1. If r is a 2D</span>
<span class="sd">        tensor then y is a 2D tensor of shape n_stimuli x 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_layer</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># hidden representation</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_layer</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
</div>
</div>
<p>The next cell contains code for initializing and running this network. We use it to decode stimulus orientation from a vector of neural responses to the very first stimulus. Note that when the initialized network class is called as a function on an input (e.g. <code class="docutils literal notranslate"><span class="pre">net(r)</span></code>), its <code class="docutils literal notranslate"><span class="pre">.forward()</span></code> method is called. This is a special property of the <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class.</p>
<p>Note that the decoded orientations at this point will be nonsense, since the network has been initialized with random weights. Below, we’ll learn how to optimize these weights for good stimulus decoding.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initialize a deep network with M=200 hidden units</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">DeepNet</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># Get neural responses (r) to and orientation (ori) to one stimulus in dataset</span>
<span class="n">r</span><span class="p">,</span> <span class="n">ori</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">resp_train</span><span class="p">,</span> <span class="n">stimuli_train</span><span class="p">)</span>  <span class="c1"># using helper function get_data</span>

<span class="c1"># Decode orientation from these neural responses using initialized network</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># compute output from network, equivalent to net.forward(r)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;decoded orientation: </span><span class="si">%.2f</span><span class="s1"> degrees&#39;</span> <span class="o">%</span> <span class="n">out</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;true orientation: </span><span class="si">%.2f</span><span class="s1"> degrees&#39;</span> <span class="o">%</span> <span class="n">ori</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="section-2-2-activation-functions">
<h2>Section 2.2: Activation functions<a class="headerlink" href="#section-2-2-activation-functions" title="Permalink to this headline">¶</a></h2>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Video 2: Nonlinear activation functions</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">YouTubeVideo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;JAdukDCQALA&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">854</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">480</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Video available at https://youtu.be/&quot;</span> <span class="o">+</span> <span class="n">video</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="n">video</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the deep network we constructed above comprises solely <strong>linear</strong> operations on each layer: each layer is just a weighted sum of all the elements in the previous layer. It turns out that linear hidden layers like this aren’t particularly useful, since a sequence of linear transformations is actually essentially the same as a single linear transformation. We can see this from the above equations by plugging in the first one into the second one to obtain</p>
<div class="amsmath math notranslate nohighlight" id="equation-182263a4-952f-4826-a860-1daaeb4de3da">
<span class="eqno">(85)<a class="headerlink" href="#equation-182263a4-952f-4826-a860-1daaeb4de3da" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    y^{(n)} = \mathbf{W}^{out} \left( \mathbf{W}^{in} \mathbf{r}^{(n)} + \mathbf{b}^{in} \right) + \mathbf{b}^{out} = \mathbf{W}^{out}\mathbf{W}^{in} \mathbf{r}^{(n)} + \left( \mathbf{W}^{out}\mathbf{b}^{in} + \mathbf{b}^{out} \right)
\end{equation}\]</div>
<p>In other words, the output is still just a weighted sum of elements in the input – the hidden layer has done nothing to change this.</p>
<p>To extend the set of computable input/output transformations to more than just weighted sums, we’ll incorporate a <strong>non-linear activation function</strong> in the hidden units. This is done by simply modifying the equation for the hidden layer activations to be</p>
<div class="amsmath math notranslate nohighlight" id="equation-8b6bc264-e8a9-4a94-9031-c8810e374786">
<span class="eqno">(86)<a class="headerlink" href="#equation-8b6bc264-e8a9-4a94-9031-c8810e374786" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    \mathbf{h}^{(n)} = \phi(\mathbf{W}^{in} \mathbf{r}^{(n)} + \mathbf{b}^{in})
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi\)</span> is referred to as the activation function. Using a non-linear activation function will ensure that the hidden layer performs a non-linear transformation of the input, which will make our network much more powerful (or <em>expressive</em>, see Bonus Section 1). In practice, deep networks <em>always</em> use non-linear activation functions.</p>
<div class="section" id="coding-exercise-2-2-nonlinear-activations">
<h3>Coding Exercise 2.2: Nonlinear Activations<a class="headerlink" href="#coding-exercise-2-2-nonlinear-activations" title="Permalink to this headline">¶</a></h3>
<p>Create a new class <code class="docutils literal notranslate"><span class="pre">DeepNetReLU</span></code> by modifying our above deep network model to use a non-linear activation function. We’ll use the linear rectification function:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5ad833c6-7e94-42c1-97a7-88f8072c998a">
<span class="eqno">(87)<a class="headerlink" href="#equation-5ad833c6-7e94-42c1-97a7-88f8072c998a" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  \phi(x) = 
  \begin{cases}
    x &amp; \text{if } x &gt; 0 \\
    0 &amp; \text{else}
  \end{cases}
\end{equation}\]</div>
<p>which can be implemented in PyTorch using <code class="docutils literal notranslate"><span class="pre">torch.relu()</span></code>. Hidden layers with this activation function are typically referred to as “<strong>Re</strong>ctified <strong>L</strong>inear <strong>U</strong>nits”, or <strong>ReLU</strong>’s.</p>
<p>Initialize this network with 10 hidden units and run on an example stimulus.</p>
<p><strong>Hint</strong>: you only need to modify the <code class="docutils literal notranslate"><span class="pre">forward()</span></code> method of the above <code class="docutils literal notranslate"><span class="pre">DeepNet()</span></code> class.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DeepNetReLU</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; network with a single hidden layer h with a RELU &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># needed to invoke the properties of the parent class nn.Module</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">in_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">)</span> <span class="c1"># neural activity --&gt; hidden units</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">out_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_hidden</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># hidden units --&gt; output</span>

  <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>

    <span class="c1">############################################################################</span>
    <span class="c1">## TO DO for students: write code for computing network output using a</span>
    <span class="c1">## rectified linear activation function for the hidden units</span>
    <span class="c1"># Fill out function and remove</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Student exercise: complete DeepNetReLU forward&quot;</span><span class="p">)</span>
    <span class="c1">############################################################################</span>

    <span class="n">h</span> <span class="o">=</span> <span class="o">...</span>
    <span class="n">y</span> <span class="o">=</span> <span class="o">...</span>

    <span class="k">return</span> <span class="n">y</span>


<span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Get neural responses (r) to and orientation (ori) to one stimulus in dataset</span>
<span class="n">r</span><span class="p">,</span> <span class="n">ori</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">resp_train</span><span class="p">,</span> <span class="n">stimuli_train</span><span class="p">)</span>

<span class="c1"># Initialize deep network with M=10 hidden units and uncomment lines below</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">DeepNetReLU</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># Decode orientation from these neural responses using initialized network</span>
<span class="c1"># net(r) is equivalent to net.forward(r)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;decoded orientation: </span><span class="si">%.2f</span><span class="s1"> degrees&#39;</span> <span class="o">%</span> <span class="n">out</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;true orientation: </span><span class="si">%.2f</span><span class="s1"> degrees&#39;</span> <span class="o">%</span> <span class="n">ori</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_1e3c4101.py"><em>Click for solution</em></a></p>
<p>You should see that the decoded orientation is 0.13 <span class="math notranslate nohighlight">\(^{\circ}\)</span> while the true orientation is 139.00 <span class="math notranslate nohighlight">\(^{\circ}\)</span>.</p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="section-3-loss-functions-and-gradient-descent">
<h1>Section 3: Loss functions and gradient descent<a class="headerlink" href="#section-3-loss-functions-and-gradient-descent" title="Permalink to this headline">¶</a></h1>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Video 3: Loss functions &amp; gradient descent</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">YouTubeVideo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;aEtKpzEuviw&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">854</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">480</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Video available at https://youtu.be/&quot;</span> <span class="o">+</span> <span class="n">video</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="n">video</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-3-1-loss-functions">
<h2>Section 3.1: Loss functions<a class="headerlink" href="#section-3-1-loss-functions" title="Permalink to this headline">¶</a></h2>
<p>Because the weights of the network are currently randomly chosen, the outputs of the network are nonsense: the decoded stimulus orientation is nowhere close to the true stimulus orientation. We’ll shortly write some code to change these weights so that the network does a better job of decoding.</p>
<p>But to do so, we first need to define what we mean by “better”. One simple way of defining this is to use the squared error</p>
<div class="amsmath math notranslate nohighlight" id="equation-5599b54e-4254-4fc3-a27d-6cf571042f5c">
<span class="eqno">(88)<a class="headerlink" href="#equation-5599b54e-4254-4fc3-a27d-6cf571042f5c" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    L = (y - \tilde{y})^2
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(y\)</span> is the network output and <span class="math notranslate nohighlight">\(\tilde{y}\)</span> is the true stimulus orientation. When the decoded stimulus orientation is far from the true stimulus orientation, <span class="math notranslate nohighlight">\(L\)</span> will be large. We thus refer to <span class="math notranslate nohighlight">\(L\)</span> as the <strong>loss function</strong>, as it quantifies how <em>bad</em> the network is at decoding stimulus orientation.</p>
<p>PyTorch actually carries with it a number of built-in loss functions. The one corresponding to the squared error is called <code class="docutils literal notranslate"><span class="pre">nn.MSELoss()</span></code>. This will take as arguments a <strong>batch</strong> of network outputs <span class="math notranslate nohighlight">\(y_1, y_2, \ldots, y_P\)</span> and corresponding target outputs <span class="math notranslate nohighlight">\(\tilde{y}_1, \tilde{y}_2, \ldots, \tilde{y}_P\)</span>, and compute the <strong>mean squared error (MSE)</strong></p>
<div class="amsmath math notranslate nohighlight" id="equation-3d309699-47ff-485a-9652-47d1ba2212be">
<span class="eqno">(89)<a class="headerlink" href="#equation-3d309699-47ff-485a-9652-47d1ba2212be" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    L = \frac{1}{P}\sum_{n=1}^P \left(y^{(n)} - \tilde{y}^{(n)}\right)^2
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(P\)</span> is the number of different stimuli in a batch, called the <em>batch size</em>.</p>
<div class="section" id="coding-exercise-3-1-computing-mse">
<h3>Coding Exercise 3.1: Computing MSE<a class="headerlink" href="#coding-exercise-3-1-computing-mse" title="Permalink to this headline">¶</a></h3>
<p>Evaluate the mean squared error for a deep network with <span class="math notranslate nohighlight">\(M=10\)</span> rectified linear units, on the decoded orientations from neural responses to 20 random stimuli.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initialize a deep network with M=10 hidden units</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">DeepNetReLU</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># Get neural responses to first 20 stimuli in the data set</span>
<span class="n">r</span><span class="p">,</span> <span class="n">ori</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">resp_train</span><span class="p">,</span> <span class="n">stimuli_train</span><span class="p">)</span>

<span class="c1"># Decode orientation from these neural responses</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1">###################################################</span>
<span class="c1">## TO DO for students: evaluate mean squared error</span>
<span class="c1">###################################################</span>

<span class="c1"># Initialize PyTorch mean squared error loss function (Hint: look at nn.MSELoss)</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1"># Evaluate mean squared error</span>
<span class="n">loss</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1"># Uncomment once above is filled in</span>
<span class="c1"># print(&#39;mean squared error: %.2f&#39; % loss)</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_8dd6b0af.py"><em>Click for solution</em></a></p>
<p>You should see a mean squared error of 42949.14.</p>
<hr class="docutils" />
</div>
</div>
<div class="section" id="section-3-2-optimization-with-gradient-descent">
<h2>Section 3.2: Optimization with gradient descent<a class="headerlink" href="#section-3-2-optimization-with-gradient-descent" title="Permalink to this headline">¶</a></h2>
<p>Our goal is now to modify the weights to make the mean squared error loss <span class="math notranslate nohighlight">\(L\)</span> as small as possible over the whole data set. To do this, we’ll use the <strong>gradient descent (GD)</strong> algorithm, which consists of iterating three steps:</p>
<ol class="simple">
<li><p><strong>Evaluate the loss</strong> on the training data,</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">train_data</span></code> are the network inputs in the training data (in our case, neural responses), and <code class="docutils literal notranslate"><span class="pre">train_labels</span></code> are the target outputs for each input (in our case, true stimulus orientations).
2. <strong>Compute the gradient of the loss</strong> with respect to each of the network weights. In PyTorch, we can do this with one line of code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
</pre></div>
</div>
<ol class="simple">
<li><p><strong>Update the network weights</strong> by descending the gradient. In Pytorch, we can do this using built-in optimizers. We’ll use the <code class="docutils literal notranslate"><span class="pre">optim.SGD</span></code> optimizer (documentation <a class="reference external" href="https://pytorch.org/docs/stable/optim.html#torch.optim.SGD">here</a>) which updates parameters along the negative gradient, scaled by a learning rate (see Bonus Section 2.1 for details). To initialize this optimizer, we have to tell it</p></li>
</ol>
<ul class="simple">
<li><p>which parameters to update, and</p></li>
<li><p>what learning rate to use</p></li>
</ul>
<p>For example, to optimize <em>all</em> the parameters of a network <code class="docutils literal notranslate"><span class="pre">net</span></code> using a learning rate of .001, the optimizer would be initialized as follows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">.001</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">.parameters()</span></code> is a method of the <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class that returns a <a class="reference external" href="https://wiki.python.org/moin/Generators">Python generator object</a> over all the parameters of that <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class (in our case, <span class="math notranslate nohighlight">\(\mathbf{W}^{in}, \mathbf{b}^{in}, \mathbf{W}^{out}, \mathbf{b}^{out}\)</span>).</p>
<p>After computing all the parameter gradients in step 2, we can then update each of these parameters using the <code class="docutils literal notranslate"><span class="pre">.step()</span></code> method of this optimizer,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, an important detail to remember is that the gradients of each parameter need to be cleared before calling <code class="docutils literal notranslate"><span class="pre">.backward()</span></code>, or else PyTorch will try to accumulate gradients across iterations. This can again be done using built-in optimizers via the method <code class="docutils literal notranslate"><span class="pre">zero_grad()</span></code>, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
</pre></div>
</div>
<p>Putting all this together, each iteration of the GD algorith will contain a block of code that looks something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Get</span> <span class="n">outputs</span> <span class="kn">from</span> <span class="nn">network</span>
<span class="n">Evaluate</span> <span class="n">loss</span>

<span class="c1"># Compute gradients</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>  <span class="c1"># clear gradients</span>
<span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

<span class="c1"># Update weights</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
<p>In the next exercise, we’ll give you a code skeleton for implementing the GD algorithm. Your job will be to fill in the blanks.</p>
<p>For the mathematical details of the GD algorithm, see Bonus Section 2.1. Note, in particular, that here we using the gradient descent algorithm, rather than the more commonly used <em>stochastic</em> gradient descent algorithm. See Bonus Section 2.2 for a more detailed discussion of how these differ and when one might need to use the stochastic variant.</p>
<div class="section" id="coding-exercise-3-2-gradient-descent-in-pytorch">
<h3>Coding Exercise 3.2: Gradient descent in PyTorch<a class="headerlink" href="#coding-exercise-3-2-gradient-descent-in-pytorch" title="Permalink to this headline">¶</a></h3>
<p>Complete the function <code class="docutils literal notranslate"><span class="pre">train()</span></code> that uses the gradient descent algorithm to optimize the weights of a given network. This function takes as input arguments</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">net</span></code>: the PyTorch network whose weights to optimize</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loss_fn</span></code>: the PyTorch loss function to use to evaluate the loss</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">train_data</span></code>: the training data to evaluate the loss on (i.e. neural responses to decode)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">train_labels</span></code>: the target outputs for each data point in <code class="docutils literal notranslate"><span class="pre">train_data</span></code> (i.e. true stimulus orientations)</p></li>
</ul>
<p>We will then train a neural network on our data and plot the loss (mean squared error) over time. When we run this function, behind the scenes PyTorch is actually changing the parameters inside this network to make the network better at decoding, so its weights will now be different than they were at initialization.</p>
<p><strong>Hint:</strong> all the code you need for doing this is provided in the above description of the GD algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span>
          <span class="n">n_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
          <span class="n">test_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">test_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">L2_penalty</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">L1_penalty</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Run gradient descent to opimize parameters of a given network</span>

<span class="sd">  Args:</span>
<span class="sd">    net (nn.Module): PyTorch network whose parameters to optimize</span>
<span class="sd">    loss_fn: built-in PyTorch loss function to minimize</span>
<span class="sd">    train_data (torch.Tensor): n_train x n_neurons tensor with neural</span>
<span class="sd">      responses to train on</span>
<span class="sd">    train_labels (torch.Tensor): n_train x 1 tensor with orientations of the</span>
<span class="sd">      stimuli corresponding to each row of train_data</span>
<span class="sd">    n_iter (int, optional): number of iterations of gradient descent to run</span>
<span class="sd">    learning_rate (float, optional): learning rate to use for gradient descent</span>
<span class="sd">    test_data (torch.Tensor, optional): n_test x n_neurons tensor with neural</span>
<span class="sd">      responses to test on</span>
<span class="sd">    test_labels (torch.Tensor, optional): n_test x 1 tensor with orientations of</span>
<span class="sd">      the stimuli corresponding to each row of test_data</span>
<span class="sd">    L2_penalty (float, optional): l2 penalty regularizer coefficient</span>
<span class="sd">    L1_penalty (float, optional): l1 penalty regularizer coefficient</span>

<span class="sd">  Returns:</span>
<span class="sd">    (list): training loss over iterations</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># Initialize PyTorch SGD optimizer</span>
  <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">)</span>

  <span class="c1"># Placeholder to save the loss at each iteration</span>
  <span class="n">train_loss</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">test_loss</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Loop over epochs</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>

    <span class="c1">######################################################################</span>
    <span class="c1">## TO DO for students: fill in missing code for GD iteration</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Student exercise: write code for GD iterations&quot;</span><span class="p">)</span>
    <span class="c1">######################################################################</span>

    <span class="c1"># compute network output from inputs in train_data</span>
    <span class="n">out</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># compute network output from inputs in train_data</span>

    <span class="c1"># evaluate loss function</span>
    <span class="k">if</span> <span class="n">L2_penalty</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">L1_penalty</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
      <span class="c1"># normal loss function</span>
      <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># custom loss function from bonus exercise 3.3</span>
      <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">in_layer</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span>
                     <span class="n">L2_penalty</span><span class="p">,</span> <span class="n">L1_penalty</span><span class="p">)</span>

    <span class="c1"># Clear previous gradients</span>
    <span class="o">...</span>

    <span class="c1"># Compute gradients</span>
    <span class="o">...</span>

    <span class="c1"># Update weights</span>
    <span class="o">...</span>

    <span class="c1"># Store current value of loss</span>
    <span class="n">train_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>  <span class="c1"># .item() needed to transform the tensor output of loss_fn to a scalar</span>

    <span class="c1"># Get loss for test_data, if given (we will use this in the bonus exercise 3.2 and 3.3)</span>
    <span class="k">if</span> <span class="n">test_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">out_test</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
      <span class="c1"># evaluate loss function</span>
      <span class="k">if</span> <span class="n">L2_penalty</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">L1_penalty</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># normal loss function</span>
        <span class="n">loss_test</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">out_test</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># (BONUS code) custom loss function from Bonus exercise 3.3</span>
        <span class="n">loss_test</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">out_test</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">in_layer</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span>
                            <span class="n">L2_penalty</span><span class="p">,</span> <span class="n">L1_penalty</span><span class="p">)</span>
      <span class="n">test_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_test</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>  <span class="c1"># .item() needed to transform the tensor output of loss_fn to a scalar</span>

    <span class="c1"># Track progress</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_iter</span> <span class="o">//</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">test_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;iteration </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s1"> | loss: </span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;iteration </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s1"> | loss: </span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> | test_loss: </span><span class="si">{</span><span class="n">loss_test</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">test_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">train_loss</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">train_loss</span><span class="p">,</span> <span class="n">test_loss</span>

<span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initialize network with 10 hidden units</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">DeepNetReLU</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># Initialize built-in PyTorch MSE loss function</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>

<span class="c1"># Run GD on data</span>
<span class="n">train_loss</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">,</span> <span class="n">resp_train</span><span class="p">,</span> <span class="n">stimuli_train</span><span class="p">)</span>

<span class="c1"># Plot the training loss over iterations of GD</span>
<span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">xkcd</span><span class="p">():</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">train_loss</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;iterations of gradient descent&#39;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;mean squared error&#39;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_41f14a37.py"><em>Click for solution</em></a></p>
<p><em>Example output:</em></p>
<img alt='Solution hint' align='left' width=560 height=416 src=https://raw.githubusercontent.com/NeuromatchAcademy/course-content/master/tutorials/W2D1_DeepLearning/static/W2D1_Tutorial1_Solution_41f14a37_3.png>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="section-4-investigating-model-and-evaluating-performance">
<h1>Section 4: Investigating model and evaluating performance<a class="headerlink" href="#section-4-investigating-model-and-evaluating-performance" title="Permalink to this headline">¶</a></h1>
<div class="section" id="section-4-1-peering-inside-the-decoding-model">
<h2>Section 4.1: Peering inside the decoding model<a class="headerlink" href="#section-4-1-peering-inside-the-decoding-model" title="Permalink to this headline">¶</a></h2>
<p>We have built a model to perform decoding that takes as input neural activity and outputs the estimated angle of the stimulus. We can imagine that an animal that needs to determine angles would have a brain area that acts like the hidden layer in our model. It transforms the neural activity from visual cortex and outputs a decision. Decisions about orientations of edges could include figuring out how to jump onto a branch, how to avoid obstacles, or determining the type of an object, e.g. food or predator.</p>
<p>What sort of connectivity would this brain area have with visual cortex? Determining this experimentally would be very difficult, perhaps we can look at the model we have and see if its structure constrains the type of connectivity we’d expect.</p>
<p>Below we will visualize the weights from the neurons in visual cortex to the hidden units <span class="math notranslate nohighlight">\(W_{in}\)</span>, and the weights from the hidden units to the output orientation <span class="math notranslate nohighlight">\(W_{out}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">W_in</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">in_layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="c1"># we can run .detach() and .numpy() to get a numpy array</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape of W_in:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_in</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">W_out</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">out_layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="c1"># we can run .detach() and .numpy() to get a numpy array</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape of W_out:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">W_in</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;hidden units&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$W_</span><span class="si">{in}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">W_out</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;hidden units&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$W_</span><span class="si">{out}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="coding-exercise-4-1-visualizing-weights">
<h3>Coding Exercise 4.1: Visualizing weights<a class="headerlink" href="#coding-exercise-4-1-visualizing-weights" title="Permalink to this headline">¶</a></h3>
<p>It’s difficult to see any structure in this weight matrix. How might we visualize it in a better way?</p>
<p>Perhaps we can sort the neurons by their preferred orientation. We will use the <code class="docutils literal notranslate"><span class="pre">resp_all</span></code> matrix which is 360 stimuli (360<span class="math notranslate nohighlight">\(^\circ\)</span> of angles) by number of neurons. How do we find the preferred orientation?</p>
<p>Let’s visualize one column of this <code class="docutils literal notranslate"><span class="pre">resp_all</span></code> matrix first as we did at the beginning of the notebook. Can you see how we might want to first process this tuning curve before choosing the preferred orientation?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">idx</span> <span class="o">=</span> <span class="mi">235</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">resp_all</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;neural response&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;stimulus orientation ($^\circ$)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;neuron </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Looking at this tuning curve, there is a bit of noise across orientations, so let’s smooth with a gaussian filter and then find the position of the maximum for each neuron. After getting the maximum position aka the “preferred orientation” for each neuron, we will re-sort the <span class="math notranslate nohighlight">\(W_{in}\)</span> matrix. The maximum position in a matrix can be computed using the <code class="docutils literal notranslate"><span class="pre">.argmax(axis=_)</span></code> function in python – make sure you specify the right axis though! Next, to get the indices of a matrix sorted you will need to use the <code class="docutils literal notranslate"><span class="pre">.argsort()</span></code> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter1d</span>

<span class="c1"># first let&#39;s smooth the tuning curves to make sure we get an accurate peak</span>
<span class="c1"># that isn&#39;t just noise</span>
<span class="n">resp_smoothed</span> <span class="o">=</span> <span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">resp_all</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">###################################################</span>
<span class="c1">## TO DO for students: find preferred orientation and resort W_in</span>
<span class="c1">###################################################</span>

<span class="c1"># find position of max response for each neuron</span>
<span class="c1"># aka preferred orientation for each neuron</span>
<span class="n">preferred_orientation</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1"># resort W_in matrix by preferred orientation</span>
<span class="n">isort</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">W_in_sorted</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1"># plot resorted W_in matrix</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># plt.imshow(W_in_sorted, aspect=&#39;auto&#39;, cmap=&#39;bwr&#39;, vmin=-1e-2, vmax=1e-2)</span>
<span class="c1"># plt.colorbar()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;sorted neurons&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;hidden units&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$W_</span><span class="si">{in}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">W_out</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;hidden units&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$W_</span><span class="si">{out}</span><span class="s1">$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_7dcde31a.py"><em>Click for solution</em></a></p>
<p><em>Example output:</em></p>
<img alt='Solution hint' align='left' width=681 height=272 src=https://raw.githubusercontent.com/NeuromatchAcademy/course-content/master/tutorials/W2D1_DeepLearning/static/W2D1_Tutorial1_Solution_7dcde31a_0.png>
</div>
<div class="section" id="think-4-interpreting-weights">
<h3>Think! 4: Interpreting weights<a class="headerlink" href="#think-4-interpreting-weights" title="Permalink to this headline">¶</a></h3>
<p>We have just visualized how the model transforms neural activity to hidden layer activity. How should we interpret these matrices? Here are some guiding questions to explore:</p>
<ul class="simple">
<li><p>Why are some of the <span class="math notranslate nohighlight">\(W_{in}\)</span> weights close to zero for some of the hidden units? Do these correspond to close to zero weights in <span class="math notranslate nohighlight">\(W_{out}\)</span>?</p></li>
<li><p>Note how each hidden unit seems to have strongest weights to two groups of neurons in <span class="math notranslate nohighlight">\(W_{in}\)</span>, corresponding to two different sets of preferred orientations. Why do you think that is? What does this tell us about the structure of the tuning curves of the neurons?</p></li>
<li><p>How can we better understand the hidden units? What simple visualization would you try next?</p></li>
</ul>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_cfa88623.py"><em>Click for solution</em></a></p>
</div>
</div>
<div class="section" id="section-4-2-generalization-performance-with-test-data">
<h2>Section 4.2: Generalization performance with test data<a class="headerlink" href="#section-4-2-generalization-performance-with-test-data" title="Permalink to this headline">¶</a></h2>
<p>Note that gradient descent is essentially an algorithm for fitting the network’s parameters to a given set of training data. Selecting this training data is thus crucial for ensuring that the optimized parameters <strong>generalize</strong> to unseen data they weren’t trained on. In our case, for example, we want to make sure that our trained network is good at decoding stimulus orientations from neural responses to any orientation, not just those in our data set.</p>
<p>To ensure this, we have split up the full data set into a <strong>training set</strong> and a <strong>testing set</strong>. In Coding Exercise 3.2, we trained a deep network by optimizing the parameters on a training set. We will now evaluate how good the optimized parameters are by using the trained network to decode stimulus orientations from neural responses in the testing set. Good decoding performance on this testing set should then be indicative of good decoding performance on the neurons’ responses to any other stimulus orientation. This procedure is commonly used in machine learning (not just in deep learning)and is typically referred to as <strong>cross-validation</strong>.</p>
<p>We will compute the MSE on the test data and plot the decoded stimulus orientations as a function of the true stimulus.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title</span>
<span class="c1">#@markdown Execute this cell to evaluate and plot test error</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">resp_test</span><span class="p">)</span>  <span class="c1"># decode stimulus orientation for neural responses in testing set</span>
<span class="n">ori</span> <span class="o">=</span> <span class="n">stimuli_test</span>  <span class="c1"># true stimulus orientations</span>
<span class="n">test_loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ori</span><span class="p">)</span>  <span class="c1"># MSE on testing set (Hint: use loss_fn initialized in previous exercise)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>  <span class="c1"># N.B. need to use .detach() to pass network output into plt.plot()</span>
<span class="n">identityLine</span><span class="p">()</span>  <span class="c1"># draw the identity line y=x; deviations from this indicate bad decoding!</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;MSE on testing set: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">test_loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>  <span class="c1"># N.B. need to use .item() to turn test_loss into a scalar</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;true stimulus orientation ($^o$)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;decoded stimulus orientation ($^o$)&#39;</span><span class="p">)</span>
<span class="n">axticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">axticks</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">axticks</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p><strong>PyTorch Note</strong>:</p>
<p>An important thing to note in the code snippet for plotting the decoded orientations is the <code class="docutils literal notranslate"><span class="pre">.detach()</span></code> method. The PyTorch <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class is special in that, behind the scenes, each of the variables inside it are linked to each other in a computational graph, for the purposes of automatic differentiation (the algorithm used in <code class="docutils literal notranslate"><span class="pre">.backward()</span></code> to compute gradients). As a result, if you want to do anything that is not a <code class="docutils literal notranslate"><span class="pre">torch</span></code> operation to the parameters or outputs of an <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class, you’ll need to first “detach” it from its computational graph. This is what the <code class="docutils literal notranslate"><span class="pre">.detach()</span></code> method does. In this hidden code above, we need to call it on the outputs of the network so that we can plot them with the <code class="docutils literal notranslate"><span class="pre">plt.plot()</span></code> function.</p>
<p>If interested, please see Bonus Section 3 to think more about model criticism (3.1), improve the loss function accordingly (3.2), and add regularization (3.3)</p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="summary">
<h1>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h1>
<p>We have now covered a number of common and powerful techniques for applying deep learning to decoding from neural data, some of which are common to almost any machine learning problem:</p>
<ul class="simple">
<li><p>Building and training deep networks using the <strong>PyTorch</strong> <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class and built-in <strong>optimizers</strong></p></li>
<li><p>Choosing and evaluating <strong>loss functions</strong></p></li>
<li><p>Testing a trained model on unseen data via <strong>cross-validation</strong>, by splitting the data into a <strong>training set and testing set</strong></p></li>
</ul>
<p>An important aspect of this tutorial was the <code class="docutils literal notranslate"><span class="pre">train()</span></code> function we wrote in exercise 3. Note that it can be used to train <em>any</em> network to minimize <em>any</em> loss function (cf. advanced exercise 6) on <em>any</em> training data. This is the power of using PyTorch to train neural networks and, for that matter, <strong>any other model</strong>! There is nothing in the <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code> class that forces us to use <code class="docutils literal notranslate"><span class="pre">nn.Linear</span></code> layers that implement neural network operations. You can actually put anything you want inside the <code class="docutils literal notranslate"><span class="pre">.__init__()</span></code> and <code class="docutils literal notranslate"><span class="pre">.forward()</span></code> methods of this class. As long as its parameters and computations involve only <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>’s, and the model is differentiable, you’ll then be able to optimize the parameters of this model in exactly the same way we optimized the deep networks here.</p>
<p>What kinds of conclusions can we draw from these sorts of analyses? If we can decode the stimulus well from visual cortex activity, that means that there is information about this stimulus available in visual cortex. Whether or not the animal uses that information to make decisions is not determined from an analysis like this. In fact mice perform poorly in orientation discrimination tasks compared to monkeys and humans, even though they have information about these stimuli in their visual cortex. Why do you think they perform poorly in orientation discrimination tasks?</p>
<p>See <a class="reference external" href="https://www.biorxiv.org/content/10.1101/679324v2">this paper</a> for some potential hypotheses, but this is totally an open question!</p>
</div>
<hr class="docutils" />
<div class="section" id="bonus">
<h1>Bonus<a class="headerlink" href="#bonus" title="Permalink to this headline">¶</a></h1>
<div class="section" id="bonus-section-1-neural-network-depth-width-and-expressivity">
<h2>Bonus Section 1: Neural network <em>depth</em>, <em>width</em> and <em>expressivity</em><a class="headerlink" href="#bonus-section-1-neural-network-depth-width-and-expressivity" title="Permalink to this headline">¶</a></h2>
<p>Two important architectural choices that always have to be made when constructing deep feed-forward networks like those used here are</p>
<ul class="simple">
<li><p>the number of hidden layers, or the network’s <em>depth</em></p></li>
<li><p>the number of units in each layer, or the layer <em>widths</em></p></li>
</ul>
<p>Here, we restricted ourselves to networks with a single hidden layer with a width of <span class="math notranslate nohighlight">\(M\)</span> units, but it is easy to see how this code could be adapted to arbitrary depths. Adding another hidden layer simply requires adding another <code class="docutils literal notranslate"><span class="pre">nn.Linear</span></code> module to the <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method and incorporating it into the <code class="docutils literal notranslate"><span class="pre">.forward()</span></code> method.</p>
<p>The depth and width of a network determine the set of input/output transormations that it can perform, often referred to as its <em>expressivity</em>. The deeper and wider the network, the more <em>expressive</em> it is; that is, the larger the class of input/output transformations it can compute. In fact, it turns out that an infinitely wide <em>or</em> infinitely deep networks can in principle <a class="reference external" href="https://en.wikipedia.org/wiki/Universal_approximation_theorem">compute (almost) <em>any</em> input/output transformation</a>.</p>
<p>A classic mathematical demonstration of the power of depth is given by the so-called <a class="reference external" href="https://medium.com/&#64;jayeshbahire/the-xor-problem-in-neural-networks-50006411840b#:~:text=The%20XOr%2C%20or%20%E2%80%9Cexclusive%20or,value%20if%20they%20are%20equal.">XOR problem</a>. This toy problem demonstrates how even a single hidden layer can drastically expand the set of input/output transformations a network can perform, relative to a shallow network with no hidden layers. The key intuition is that the hidden layer allows you to represent the input in a new format, which can then allow you to do almost anything you want with it. The <em>wider</em> this hidden layer, the more flexibility you have in this representation. In particular, if you have more hidden units than input units, then the hidden layer representation of the input is higher-dimensional than the raw data representation. This higher dimensionality effectively gives you more “room” to perform arbitrary computations in. It turns out that even with just this one hidden layer, if you make it wide enough you can actually approximate any input/output transformation you want. See <a class="reference external" href="http://neuralnetworksanddeeplearning.com/chap4.html">here</a> for a neat visual demonstration of this.</p>
<p>In practice, however, it turns out that increasing depth seems to grant more expressivity with fewer units than increasing width does (for reasons that are not well understood). It is for this reason that truly <em>deep</em> networks are almost always used in machine learning, which is why this set of techniques is often referred to as <em>deep</em> learning.</p>
<p>That said, there is a cost to making networks deeper and wider. The bigger your network, the more parameters (i.e. weights and biases) it has, which need to be optimized! The extra expressivity afforded by higher width and/or depth thus carries with it (at least) two problems:</p>
<ul class="simple">
<li><p>optimizing more parameters usually requires more data</p></li>
<li><p>a more highly parameterized network is more prone to overfit to the training data, so requires more sophisticated optimization algorithms to ensure generalization</p></li>
</ul>
</div>
<div class="section" id="bonus-section-2-gradient-descent">
<h2>Bonus Section 2: Gradient descent<a class="headerlink" href="#bonus-section-2-gradient-descent" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bonus-section-2-1-gradient-descent-equations">
<h3>Bonus Section 2.1: Gradient descent equations<a class="headerlink" href="#bonus-section-2-1-gradient-descent-equations" title="Permalink to this headline">¶</a></h3>
<p>Here we provide the equations for the three steps of the gradient descent algorithm, as applied to our decoding problem:</p>
<ol class="simple">
<li><p><strong>Evaluate the loss</strong> on the training data. For a mean squared error loss, this is given by</p></li>
</ol>
<div class="amsmath math notranslate nohighlight" id="equation-1f7d0518-1b93-427e-8bfc-a2b5b905a352">
<span class="eqno">(90)<a class="headerlink" href="#equation-1f7d0518-1b93-427e-8bfc-a2b5b905a352" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    L = \frac{1}{P}\sum_{n=1}^P (y^{(n)} - \tilde{y}^{(n)})^2
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(y^{(n)}\)</span> denotes the stimulus orientation decoded from the population response <span class="math notranslate nohighlight">\(\mathbf{r}^{(n)}\)</span> to the <span class="math notranslate nohighlight">\(n\)</span>th stimulus in the training data, and <span class="math notranslate nohighlight">\(\tilde{y}^{(n)}\)</span> is the true orientation of that stimulus. <span class="math notranslate nohighlight">\(P\)</span> denotes the total number of data samples in the training set. In the syntax of our <code class="docutils literal notranslate"><span class="pre">train()</span></code> function above, <span class="math notranslate nohighlight">\(\mathbf{r}^{(n)}\)</span> is given by <code class="docutils literal notranslate"><span class="pre">train_data[n,</span> <span class="pre">:]</span></code> and <span class="math notranslate nohighlight">\(\tilde{y}^{(n)}\)</span> by <code class="docutils literal notranslate"><span class="pre">train_labels[n]</span></code>.</p>
<ol class="simple">
<li><p><strong>Compute the gradient of the loss</strong> with respect to each of the network weights. In our case, this entails computing the quantities</p></li>
</ol>
<div class="amsmath math notranslate nohighlight" id="equation-6ef001e4-dec5-419c-bd4b-6cab64af6527">
<span class="eqno">(91)<a class="headerlink" href="#equation-6ef001e4-dec5-419c-bd4b-6cab64af6527" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    \frac{\partial L}{\partial \mathbf{W}^{in}}, \frac{\partial L}{\partial \mathbf{b}^{in}}, \frac{\partial L}{\partial \mathbf{W}^{out}}, \frac{\partial L}{\partial \mathbf{b}^{out}}
\end{equation}\]</div>
<p>Usually, we would require lots of math in order to derive each of these gradients, and lots of code to compute them. But this is where PyTorch comes to the rescue! Using a cool technique called <a class="reference external" href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>, PyTorch automatically calculates these gradients when the <code class="docutils literal notranslate"><span class="pre">.backward()</span></code> function is called.</p>
<p>More specifically, when this function is called on a particular variable (e.g. <code class="docutils literal notranslate"><span class="pre">loss</span></code>, as above), PyTorch will compute the gradients with respect to each network parameter. These are computed and stored behind the scenes, and can be accessed through the <code class="docutils literal notranslate"><span class="pre">.grad</span></code> attribute of each of the network’s parameters. As we saw above, however, we actually never need to look at or call these gradients when implementing gradient descent, as this can be taken care of by PyTorch’s built-in optimizers, like <code class="docutils literal notranslate"><span class="pre">optim.SGD</span></code>.</p>
<ol class="simple">
<li><p><strong>Update the network weights</strong> by descending the gradient:</p></li>
</ol>
<div class="amsmath math notranslate nohighlight" id="equation-ff082582-55a5-41e9-b522-d1a123842748">
<span class="eqno">(92)<a class="headerlink" href="#equation-ff082582-55a5-41e9-b522-d1a123842748" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \mathbf{W}^{in} &amp;\leftarrow \mathbf{W}^{in} - \alpha \frac{\partial L}{\partial \mathbf{W}^{in}} \\
    \mathbf{b}^{in} &amp;\leftarrow \mathbf{b}^{in} - \alpha \frac{\partial L}{\partial \mathbf{b}^{in}} \\
    \mathbf{W}^{out} &amp;\leftarrow \mathbf{W}^{out} - \alpha \frac{\partial L}{\partial \mathbf{W}^{out}} \\
    \mathbf{b}^{out} &amp;\leftarrow \mathbf{b}^{out} - \alpha \frac{\partial L}{\partial \mathbf{b}^{out}}
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is called the <strong>learning rate</strong>. This <strong>hyperparameter</strong> of the SGD algorithm controls how far we descend the gradient on each iteration. It should be as large as possible so that fewer iterations are needed, but not too large so as to avoid parameter updates from skipping over minima in the loss landscape.</p>
<p>While the equations written down here are specific to the network and loss function considered in this tutorial, the code provided above for implementing these three steps is completely general: no matter what loss function or network you are using, exactly the same commands can be used to implement these three steps.</p>
<p>The way that the gradients are calculated is called <strong>backpropagation</strong>. We have a loss function:</p>
<div class="amsmath math notranslate nohighlight" id="equation-a657c01f-a7d6-4ee8-bcab-4a127581a913">
<span class="eqno">(93)<a class="headerlink" href="#equation-a657c01f-a7d6-4ee8-bcab-4a127581a913" title="Permalink to this equation">¶</a></span>\[\begin{align}
    L &amp;= (y - \tilde{y})^2 \\
     &amp;= (\mathbf{W}^{out} \mathbf{h} - \tilde{y})^2
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{h} = \phi(\mathbf{W}^{in} \mathbf{r} + \mathbf{b}^{in})\)</span>
You may see that <span class="math notranslate nohighlight">\(\frac{\partial L}{\partial \mathbf{W}^{out}}\)</span> is simple to calculate as it is on the outside of the equation (it is also a vector in this case, not a matrix, so the derivative is standard):</p>
<div class="amsmath math notranslate nohighlight" id="equation-51c0308b-3d44-4be0-82e4-008da2889786">
<span class="eqno">(94)<a class="headerlink" href="#equation-51c0308b-3d44-4be0-82e4-008da2889786" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\frac{\partial L}{\partial \mathbf{W}^{out}} = 2 (\mathbf{h} - \tilde{y})
\end{equation}\]</div>
<p>Now let’s compute the derivative with respect to <span class="math notranslate nohighlight">\(\mathbf{W}^{in}\)</span> using the chain rule. Note it is only positive if the output is positive due to the RELU <span class="math notranslate nohighlight">\(\phi\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-626e2973-5591-4741-ad8d-4647cfd3e79f">
<span class="eqno">(95)<a class="headerlink" href="#equation-626e2973-5591-4741-ad8d-4647cfd3e79f" title="Permalink to this equation">¶</a></span>\[\begin{align}
\frac{\partial L}{\partial \mathbf{W}^{in}} &amp;= \begin{cases}
    \frac{\partial L}{\partial \mathbf{W}^{out}} \frac{\partial \mathbf{h}}{\partial \mathbf{W}^{in}}  &amp; \text{if }  \mathbf{h} &gt; 0 \\
    0 &amp; \text{else}
  \end{cases} \\
  &amp;= \begin{cases}
    2 (\mathbf{h} - \tilde{y}) \mathbf{r}^\top  &amp; \text{if }  \mathbf{h} &gt; 0 \\
    0 &amp; \text{else}
  \end{cases}
\end{align}\]</div>
<p>It is most efficient to compute the derivative once for the last layer, then once for the next layer and multiply by the previous layer’s derivative and so on using the chain rule. Each of these operations is relatively fast, making training of deep networks feasible.</p>
<p>The command <code class="docutils literal notranslate"><span class="pre">loss.backward()</span></code> computes these gradients for the defined <code class="docutils literal notranslate"><span class="pre">loss</span></code> with respect to each network parameter. The computation is done using <a class="reference external" href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>, which implements backpropagation. Note that this works no matter how big/small the network is, allowing us to perform gradient descent for any deep network model built using PyTorch.</p>
</div>
<div class="section" id="bonus-section-2-2-stochastic-gradient-descent-sgd-vs-gradient-descent-gd">
<h3>Bonus Section 2.2: <em>Stochastic</em> gradient descent (SGD) vs. gradient descent (GD)<a class="headerlink" href="#bonus-section-2-2-stochastic-gradient-descent-sgd-vs-gradient-descent-gd" title="Permalink to this headline">¶</a></h3>
<p>In this tutorial, we used the gradient descent algorithm, which differs in a subtle yet very important way from the more commonly used <strong>stochastic gradient descent (SGD)</strong> algorithm. The key difference is in the very first step of each iteration, where in the GD algorithm we evaluate the loss <em>at every data sample in the training set</em>. In SGD, on the other hand, we evaluate the loss only at a random subset of data samlpes from the full training set, called a <strong>mini-batch</strong>. At each iteration, we randomly sample a mini-batch to perform steps 1-3 on. All the above equations still hold, but now the <span class="math notranslate nohighlight">\(P\)</span> data samples <span class="math notranslate nohighlight">\(\mathbf{r}^{(n)}, \tilde{y}^{(n)}\)</span> denote a mini-batch of <span class="math notranslate nohighlight">\(P\)</span> random samples from the training set, rather than the whole training set.</p>
<p>There are several reasons why one might want to use SGD instead of GD. The first is that the training set might be too big, so that we actually can’t actually evaluate the loss on every single data sample in it. In this case, GD is simply infeasible, so we have no choice but to turn to SGD, which bypasses the restrictive memory demands of GD by sub-sampling the training set into smaller mini-batches.</p>
<p>But, even when GD is feasible, SGD turns out to be generally better. The stochasticity induced by the extra random sampling step in SGD effectively adds some noise in the search for local minima of the loss function. This can be really useful for avoiding potential local minima, and enforce that whatever minimum is converged to is a good one. This is particularly important when networks are wider and/or deeper, in which case the large number of parameters can lead to overfitting.</p>
<p>Here, we used only GD because (1) it is simpler, and (2) it suffices for the problem being considered here. Because we have so many neurons in our data set, decoding is not too challenging and doesn’t require a particularly deep or wide network. The small number of parameters in our deep networks therefore can be optimized without a problem using GD.</p>
</div>
</div>
<div class="section" id="bonus-section-3-evaluating-improving-models">
<h2>Bonus Section 3: Evaluating &amp; improving models<a class="headerlink" href="#bonus-section-3-evaluating-improving-models" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<div class="section" id="bonus-section-3-1-model-criticism">
<h3>Bonus Section 3.1: Model criticism<a class="headerlink" href="#bonus-section-3-1-model-criticism" title="Permalink to this headline">¶</a></h3>
<p>Let’s now take a step back and think about how our model is succeeding/failing and how to improve it.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title</span>
<span class="c1">#@markdown Execute this cell to plot decoding error</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">resp_test</span><span class="p">)</span>  <span class="c1"># decode stimulus orientation for neural responses in testing set</span>
<span class="n">ori</span> <span class="o">=</span> <span class="n">stimuli_test</span>  <span class="c1"># true stimulus orientations</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">out</span> <span class="o">-</span> <span class="n">ori</span>  <span class="c1"># decoding error</span>


<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">error</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>   <span class="c1"># plot decoding error as a function of true orientation (make sure all arguments to plt.plot() have been detached from PyTorch network!)</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;true stimulus orientation ($^o$)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;decoding error ($^o$)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">360</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bonus-think-3-1-delving-into-error-problems">
<h4>Bonus Think! 3.1: Delving into error problems<a class="headerlink" href="#bonus-think-3-1-delving-into-error-problems" title="Permalink to this headline">¶</a></h4>
<p>In the cell below, we will plot the <em>decoding error</em> for each neural response in the testing set. The decoding error is defined as the decoded stimulus orientation minus true stimulus orientation</p>
<div class="amsmath math notranslate nohighlight" id="equation-f3b2597c-46ae-4d48-a0b7-1450b0204692">
<span class="eqno">(96)<a class="headerlink" href="#equation-f3b2597c-46ae-4d48-a0b7-1450b0204692" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  \text{decoding error} = y^{(n)} - \tilde{y}^{(n)}
\end{equation}\]</div>
<p>In particular, we plot decoding error as a function of the true stimulus orientation.</p>
<ul class="simple">
<li><p>Are some stimulus orientations harder to decode than others?</p></li>
<li><p>If so, in what sense? Are the decoded orientations for these stimuli more variable and/or are they biased?</p></li>
<li><p>Can you explain this variability/bias? What makes these stimulus orientations different from the others?</p></li>
<li><p>(Will be addressed in next exercise) Can you think of a way to modify the deep network in order to avoid this?</p></li>
</ul>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_de0cd867.py"><em>Click for solution</em></a></p>
</div>
</div>
<div class="section" id="bonus-section-3-2-improving-the-loss-function">
<h3>Bonus Section 3.2: Improving the loss function<a class="headerlink" href="#bonus-section-3-2-improving-the-loss-function" title="Permalink to this headline">¶</a></h3>
<p>As illustrated in the previous exercise, the squared error is not a good loss function for circular quantities like angles, since two angles that are very close (e.g. <span class="math notranslate nohighlight">\(1^o\)</span> and <span class="math notranslate nohighlight">\(359^o\)</span>) might actually have a very large squared error.</p>
<p>Here, we’ll avoid this problem by changing our loss function to treat our decoding problem as a <strong>classification problem</strong>. Rather than estimating the <em>exact</em> angle of the stimulus, we’ll now aim to construct a decoder that classifies the stimulus into one of <span class="math notranslate nohighlight">\(C\)</span> classes, corresponding to different bins of angles of width <span class="math notranslate nohighlight">\(b = \frac{360}{C}\)</span>. The true class <span class="math notranslate nohighlight">\(\tilde{y}^{(n)}\)</span> of stimulus <span class="math notranslate nohighlight">\(i\)</span> is now given by</p>
<div class="amsmath math notranslate nohighlight" id="equation-dfd9f051-e88c-4579-bc7a-317d82f9c305">
<span class="eqno">(97)<a class="headerlink" href="#equation-dfd9f051-e88c-4579-bc7a-317d82f9c305" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  \tilde{y}^{(n)} =
  \begin{cases}
    1 &amp;\text{if angle of stimulus $n$ is in the range } [0, b] \\
    2 &amp;\text{if angle of stimulus $n$ is in the range } [b, 2b] \\
    3 &amp;\text{if angle of stimulus $n$ is in the range } [2b, 3b] \\
    \vdots \\
    C &amp;\text{if angle of stimulus $n$ is in the range } [(C-1)b, 360]
  \end{cases}
\end{equation}\]</div>
<p>We have a helper function <code class="docutils literal notranslate"><span class="pre">stimulus_class</span></code> that will extract <code class="docutils literal notranslate"><span class="pre">n_classes</span></code> stimulus classes for us from the stimulus orientations.</p>
<p>To decode the stimulus class from neural responses, we’ll use a deep network that outputs a <span class="math notranslate nohighlight">\(C\)</span>-dimensional vector of probabilities <span class="math notranslate nohighlight">\(\mathbf{p} = \begin{bmatrix} p_1, p_2, \ldots, p_C \end{bmatrix}^T\)</span>, corresponding to the estimated probabilities of the stimulus belonging to each class <span class="math notranslate nohighlight">\(1, 2, \ldots, C\)</span>.</p>
<p>To ensure the network’s outputs are indeed probabilities (i.e. they are positive numbers between 0 and 1, and sum to 1), we’ll use a <a class="reference external" href="https://en.wikipedia.org/wiki/Softmax_function">softmax function</a> to transform the real-valued outputs from the hidden layer into probabilities. Letting <span class="math notranslate nohighlight">\(\sigma(\cdot)\)</span> denote this softmax function, the equations describing our network are</p>
<div class="amsmath math notranslate nohighlight" id="equation-5b0d3582-9b4d-43a5-98f7-b0d99ac46f70">
<span class="eqno">(98)<a class="headerlink" href="#equation-5b0d3582-9b4d-43a5-98f7-b0d99ac46f70" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \mathbf{h}^{(n)} &amp;= \phi(\mathbf{W}^{in} \mathbf{r}^{(n)} + \mathbf{b}^{in}), &amp;&amp; [\mathbf{W}^{in}: M \times N], \\
    \mathbf{p}^{(n)} &amp;= \sigma(\mathbf{W}^{out} \mathbf{h}^{(n)} + \mathbf{b}^{out}),  &amp;&amp; [\mathbf{W}^{out}: C \times M],
\end{align}\]</div>
<p>The decoded stimulus class is then given by that assigned the highest probability by the network:</p>
<div class="amsmath math notranslate nohighlight" id="equation-b0deeba2-72cb-4cf3-8ca1-62528e8e53ed">
<span class="eqno">(99)<a class="headerlink" href="#equation-b0deeba2-72cb-4cf3-8ca1-62528e8e53ed" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  y^{(n)} = \underset{i}{\arg\max} \,\, p_i
\end{equation}\]</div>
<p>The softmax function can be implemented in PyTorch simply using <code class="docutils literal notranslate"><span class="pre">torch.softmax()</span></code>.</p>
<p>Often <em>log</em> probabilities are easier to work with than actual probabilities, because probabilities tend to be very small numbers that computers have trouble representing. We’ll therefore actually use the logarithm of the softmax as the output of our network,</p>
<div class="amsmath math notranslate nohighlight" id="equation-6525033a-c06e-4395-8020-881395ac5b5f">
<span class="eqno">(100)<a class="headerlink" href="#equation-6525033a-c06e-4395-8020-881395ac5b5f" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    \mathbf{l}^{(n)} = \log \left( \mathbf{p}^{(n)} \right)
\end{equation}\]</div>
<p>which can implemented in PyTorch together with the softmax via an <code class="docutils literal notranslate"><span class="pre">nn.LogSoftmax</span></code> layer. The nice thing about the logarithmic function is that it’s <em>monotonic</em>, so if one probability is larger/smaller than another, then its logarithm is also larger/smaller than the other’s. We therefore have that</p>
<div class="amsmath math notranslate nohighlight" id="equation-79e65424-5879-497d-8d5b-ff6b4d700e26">
<span class="eqno">(101)<a class="headerlink" href="#equation-79e65424-5879-497d-8d5b-ff6b4d700e26" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  y^{(n)} = \underset{i}{\arg\max} \,\, p_i^{(n)} = \underset{i}{\arg\max} \, \log p_i^{(n)} = \underset{i}{\arg\max} \,\, l_i^{(n)}
\end{equation}\]</div>
<p>See the next cell for code for constructing a deep network with one hidden layer that of ReLU’s that outputs a vector of log probabilities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Deep network for classification</span>
<span class="k">class</span> <span class="nc">DeepNetSoftmax</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Deep Network with one hidden layer, for classification</span>

<span class="sd">  Args:</span>
<span class="sd">    n_inputs (int): number of input units</span>
<span class="sd">    n_hidden (int): number of units in hidden layer</span>
<span class="sd">    n_classes (int): number of outputs, i.e. number of classes to output</span>
<span class="sd">      probabilities for</span>

<span class="sd">  Attributes:</span>
<span class="sd">    in_layer (nn.Linear): weights and biases of input layer</span>
<span class="sd">    out_layer (nn.Linear): weights and biases of output layer</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># needed to invoke the properties of the parent class nn.Module</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">in_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_hidden</span><span class="p">)</span>  <span class="c1"># neural activity --&gt; hidden units</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">out_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_hidden</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">)</span>  <span class="c1"># hidden units --&gt; outputs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logprob</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># probabilities across columns should sum to 1 (each output row corresponds to a different input)</span>

  <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Predict stimulus orientation bin from neural responses</span>

<span class="sd">    Args:</span>
<span class="sd">      r (torch.Tensor): n_stimuli x n_inputs tensor with neural responses to n_stimuli</span>

<span class="sd">    Returns:</span>
<span class="sd">      torch.Tensor: n_stimuli x n_classes tensor with predicted class probabilities</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_layer</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="n">logp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logprob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_layer</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">logp</span>
</pre></div>
</div>
</div>
</div>
<p>What should our loss function now be? Ideally, we want the probabilities outputted by our network to be such that the probability of the true stimulus class is high. One way to formalize this is to say that we want to maximize the <em>log</em> probability of the true stimulus class <span class="math notranslate nohighlight">\(\tilde{y}^{(n)}\)</span> under the class probabilities predicted by the network,</p>
<div class="amsmath math notranslate nohighlight" id="equation-a5770725-21d6-4507-8428-a750ed7ea136">
<span class="eqno">(102)<a class="headerlink" href="#equation-a5770725-21d6-4507-8428-a750ed7ea136" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  \log \left( \text{predicted probability of stimulus } n \text{ being of class } \tilde{y}^{(n)} \right) = \log p^{(n)}_{\tilde{y}^{(n)}} = l^{(n)}_{\tilde{y}^{(n)}}
\end{equation}\]</div>
<p>To turn this into a loss function to be <em>minimized</em>, we can then simply multiply it by -1: maximizing the log probability is the same as minimizing the <em>negative</em> log probability. Summing over a batch of <span class="math notranslate nohighlight">\(P\)</span> inputs, our loss function is then given by</p>
<div class="amsmath math notranslate nohighlight" id="equation-020ed564-fb58-455a-8aca-401ab2952337">
<span class="eqno">(103)<a class="headerlink" href="#equation-020ed564-fb58-455a-8aca-401ab2952337" title="Permalink to this equation">¶</a></span>\[\begin{equation}
  L = -\sum_{n=1}^P \log p^{(n)}_{\tilde{y}^{(n)}} = -\sum_{n=1}^P l^{(n)}_{\tilde{y}^{(n)}}
\end{equation}\]</div>
<p>In the deep learning community, this loss function is typically referred to as the <strong>cross-entropy</strong>, or <strong>negative log likelihood</strong>. The corresponding built-in loss function in PyTorch is <code class="docutils literal notranslate"><span class="pre">nn.NLLLoss()</span></code> (documentation <a class="reference external" href="https://pytorch.org/docs/master/generated/torch.nn.CrossEntropyLoss.html">here</a>).</p>
<div class="section" id="bonus-coding-exercise-3-2-a-new-loss-function">
<h4>Bonus Coding Exercise 3.2: A new loss function<a class="headerlink" href="#bonus-coding-exercise-3-2-a-new-loss-function" title="Permalink to this headline">¶</a></h4>
<p>In the next cell, we’ve provided most of the code to train and test a network to decode stimulus orientations via classification, by minimizing the negative log likelihood. Fill in the missing pieces.</p>
<p>Once you’ve done this, have a look at the plotted results. Does changing the loss function from mean squared error to a classification loss solve our problems? Note that errors may still occur – but are these errors as bad as the ones that our network above was making?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decode_orientation</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">,</span>
                       <span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">test_data</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">,</span>
                       <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">L2_penalty</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">L1_penalty</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Initialize, train, and test deep network to decode binned orientation from neural responses</span>

<span class="sd">  Args:</span>
<span class="sd">    net (nn.Module): deep network to run</span>
<span class="sd">    n_classes (scalar): number of classes in which to bin orientation</span>
<span class="sd">    loss_fn (function): loss function to run</span>
<span class="sd">    train_data (torch.Tensor): n_train x n_neurons tensor with neural</span>
<span class="sd">      responses to train on</span>
<span class="sd">    train_labels (torch.Tensor): n_train x 1 tensor with orientations of the</span>
<span class="sd">      stimuli corresponding to each row of train_data, in radians</span>
<span class="sd">    test_data (torch.Tensor): n_test x n_neurons tensor with neural</span>
<span class="sd">      responses to train on</span>
<span class="sd">    test_labels (torch.Tensor): n_test x 1 tensor with orientations of the</span>
<span class="sd">      stimuli corresponding to each row of train_data, in radians</span>
<span class="sd">    n_iter (int, optional): number of iterations to run optimization</span>
<span class="sd">    L2_penalty (float, optional): l2 penalty regularizer coefficient</span>
<span class="sd">    L1_penalty (float, optional): l1 penalty regularizer coefficient</span>

<span class="sd">  Returns:</span>
<span class="sd">    (list, torch.Tensor): training loss over iterations, n_test x 1 tensor with predicted orientations of the</span>
<span class="sd">      stimuli from decoding neural network</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># Bin stimulus orientations in training set</span>
  <span class="n">train_binned_labels</span> <span class="o">=</span> <span class="n">stimulus_class</span><span class="p">(</span><span class="n">train_labels</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">)</span>
  <span class="n">test_binned_labels</span> <span class="o">=</span> <span class="n">stimulus_class</span><span class="p">(</span><span class="n">test_labels</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">)</span>


  <span class="c1"># Run GD on training set data, using learning rate of 0.1</span>
  <span class="c1"># (add optional arguments test_data and test_binned_labels!)</span>
  <span class="n">train_loss</span><span class="p">,</span> <span class="n">test_loss</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">train_binned_labels</span><span class="p">,</span>
                                <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">test_data</span><span class="o">=</span><span class="n">test_data</span><span class="p">,</span>
                                <span class="n">test_labels</span><span class="o">=</span><span class="n">test_binned_labels</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">n_iter</span><span class="p">,</span>
                                <span class="n">L2_penalty</span><span class="o">=</span><span class="n">L2_penalty</span><span class="p">,</span> <span class="n">L1_penalty</span><span class="o">=</span><span class="n">L1_penalty</span><span class="p">)</span>

  <span class="c1"># Decode neural responses in testing set data</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
  <span class="n">out_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># predicted classes</span>

  <span class="n">frac_correct</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_labels</span><span class="o">==</span><span class="n">test_binned_labels</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_binned_labels</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&gt;&gt;&gt; fraction correct = </span><span class="si">{</span><span class="n">frac_correct</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">train_loss</span><span class="p">,</span> <span class="n">test_loss</span><span class="p">,</span> <span class="n">out_labels</span>

<span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">n_classes</span> <span class="o">=</span> <span class="mi">20</span>

<span class="c1">##############################################################################</span>
<span class="c1">## TODO for students: fill out missing pieces below to initialize network and</span>
<span class="c1"># define loss function</span>
<span class="c1">##############################################################################</span>

<span class="c1"># Initialize network</span>
<span class="n">net</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># use M=20 hidden units</span>

<span class="c1"># Initialize built-in PyTorch negative log likelihood loss function</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1"># Uncomment below to train network and run it on test images</span>
<span class="c1"># this function uses the train function you wrote before</span>
<span class="c1">#train_loss, test_loss, predicted_test_labels = decode_orientation(net, n_classes, loss_fn,</span>
<span class="c1">#                                                                  resp_train, stimuli_train, resp_test, stimuli_test)</span>

<span class="c1"># Plot results</span>
<span class="c1">#plot_decoded_results(train_loss, test_loss, stimuli_test, predicted_test_labels)</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_6386844c.py"><em>Click for solution</em></a></p>
<p><em>Example output:</em></p>
<img alt='Solution hint' align='left' width=1134 height=413 src=https://raw.githubusercontent.com/NeuromatchAcademy/course-content/master/tutorials/W2D1_DeepLearning/static/W2D1_Tutorial1_Solution_6386844c_5.png>
<p>How do the weights <span class="math notranslate nohighlight">\(W_{in}\)</span> from the neurons to the hidden layer look now?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">W_in</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">in_layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="c1"># we can run detach and numpy to get a numpy array</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape of W_in:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_in</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">W_in</span><span class="p">[:,</span><span class="n">isort</span><span class="p">],</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">5e-3</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;hidden units&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$W_</span><span class="si">{in}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="bonus-section-3-3-regularization">
<h3>Bonus Section 3.3: Regularization<a class="headerlink" href="#bonus-section-3-3-regularization" title="Permalink to this headline">¶</a></h3>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Video 4: Regularization</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">YouTubeVideo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;Qnn5OPHKo5w&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">854</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">480</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Video available at https://youtube.com/watch?v=&quot;</span> <span class="o">+</span> <span class="n">video</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="n">video</span>
</pre></div>
</div>
</div>
</div>
<p>As discussed in the lecture, it is often important to incorporate regularization terms into the loss function to avoid overfitting. In particular, in this case, we will use these terms to enforce sparsity in the linear layer from neurons to hidden units.</p>
<p>Here we’ll consider the classic L2 regularization penalty <span class="math notranslate nohighlight">\(\mathcal{R}_{L2}\)</span>, which is the sum of squares of each weight in the network <span class="math notranslate nohighlight">\(\sum_{ij} {\mathbf{W}^{out}_{ij}}^2\)</span> times a constant that we call <code class="docutils literal notranslate"><span class="pre">L2_penalty</span></code>.</p>
<p>We will also add an L1 regularization penalty <span class="math notranslate nohighlight">\(\mathcal{R}_{L1}\)</span> to enforce sparsity of the weights, which is the sum of the absolute values of the weights <span class="math notranslate nohighlight">\(\sum_{ij} |{\mathbf{W}^{out}_{ij}}|\)</span> times a constant that we call <code class="docutils literal notranslate"><span class="pre">L1_penalty</span></code>.</p>
<p>We will add both of these to the loss function:</p>
<div class="amsmath math notranslate nohighlight" id="equation-0821c9c0-e5f9-4e61-a1a4-96086e5401eb">
<span class="eqno">(104)<a class="headerlink" href="#equation-0821c9c0-e5f9-4e61-a1a4-96086e5401eb" title="Permalink to this equation">¶</a></span>\[\begin{equation}
    L = (y - \tilde{y})^2 + \mathcal{R}_{L2} + \mathcal{R}_{L1}
\end{equation}\]</div>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">L2_penalty</span></code> and <code class="docutils literal notranslate"><span class="pre">L1_penalty</span></code> are inputs to the train function.</p>
<div class="section" id="bonus-coding-exercise-3-3-add-regularization-to-training">
<h4>Bonus Coding Exercise 3.3: Add regularization to training<a class="headerlink" href="#bonus-coding-exercise-3-3-add-regularization-to-training" title="Permalink to this headline">¶</a></h4>
<p>We will create a new loss function that adds L1 and L2 regularization.
In particular, you will:</p>
<ul class="simple">
<li><p>add L2 loss penalty to the weights</p></li>
<li><p>add L1 loss penalty to the weights</p></li>
</ul>
<p>We will then train the network using this loss function. Full training will take a few minutes: if you want to train for just a few steps to speed up the code while iterating on your code, you can decrease the n_iter input from 500.</p>
<p>Hint: since we are using <code class="docutils literal notranslate"><span class="pre">torch</span></code> instead of <code class="docutils literal notranslate"><span class="pre">np</span></code>, we will use <code class="docutils literal notranslate"><span class="pre">torch.abs</span></code> instead of <code class="docutils literal notranslate"><span class="pre">np.absolute</span></code>. You can use <code class="docutils literal notranslate"><span class="pre">torch.sum</span></code> or <code class="docutils literal notranslate"><span class="pre">.sum()</span></code> to sum over a tensor.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">regularized_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">L2_penalty</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">L1_penalty</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;loss function with L2 and L1 regularization</span>

<span class="sd">  Args:</span>
<span class="sd">    output (torch.Tensor): output of network</span>
<span class="sd">    target (torch.Tensor): neural response network is trying to predict</span>
<span class="sd">    weights (torch.Tensor): linear layer weights from neurons to hidden units (net.in_layer.weight)</span>
<span class="sd">    L2_penalty : scaling factor of sum of squared weights</span>
<span class="sd">    L1_penalty : scalaing factor for sum of absolute weights</span>

<span class="sd">  Returns:</span>
<span class="sd">    (torch.Tensor) mean-squared error with L1 and L2 penalties added</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1">##############################################################################</span>
  <span class="c1"># TO DO: add L1 and L2 regularization to the loss function</span>
  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Student exercise: complete regularized_loss&quot;</span><span class="p">)</span>
  <span class="c1">##############################################################################</span>

  <span class="n">loss_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
  <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

  <span class="n">L2</span> <span class="o">=</span> <span class="n">L2_penalty</span> <span class="o">*</span> <span class="o">...</span>
  <span class="n">L1</span> <span class="o">=</span> <span class="n">L1_penalty</span> <span class="o">*</span> <span class="o">...</span>
  <span class="n">loss</span> <span class="o">+=</span> <span class="n">L1</span> <span class="o">+</span> <span class="n">L2</span>

  <span class="k">return</span> <span class="n">loss</span>

<span class="c1"># Set random seeds for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">n_classes</span> <span class="o">=</span> <span class="mi">20</span>

<span class="c1"># Initialize network</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">DeepNetSoftmax</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">)</span>  <span class="c1"># use M=20 hidden units</span>

<span class="c1"># Initialize built-in PyTorch MSE loss function</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">regularized_loss</span>

<span class="c1"># Here you can play with L2_penalty &gt; 0, L1_penalty &gt; 0</span>
<span class="n">train_loss</span><span class="p">,</span> <span class="n">test_loss</span><span class="p">,</span> <span class="n">predicted_test_labels</span> <span class="o">=</span> <span class="n">decode_orientation</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">,</span> <span class="n">loss_fn</span><span class="p">,</span>
                                                                  <span class="n">resp_train</span><span class="p">,</span> <span class="n">stimuli_train</span><span class="p">,</span>
                                                                  <span class="n">resp_test</span><span class="p">,</span> <span class="n">stimuli_test</span><span class="p">,</span>
                                                                  <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                                                  <span class="n">L2_penalty</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span>
                                                                  <span class="n">L1_penalty</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">plot_decoded_results</span><span class="p">(</span><span class="n">train_loss</span><span class="p">,</span> <span class="n">test_loss</span><span class="p">,</span> <span class="n">stimuli_test</span><span class="p">,</span> <span class="n">predicted_test_labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="https://github.com/NeuromatchAcademy/course-content/tree/master//tutorials/W2D1_DeepLearning/solutions/W2D1_Tutorial1_Solution_e53cd8ce.py"><em>Click for solution</em></a></p>
<p><em>Example output:</em></p>
<img alt='Solution hint' align='left' width=1134 height=413 src=https://raw.githubusercontent.com/NeuromatchAcademy/course-content/master/tutorials/W2D1_DeepLearning/static/W2D1_Tutorial1_Solution_e53cd8ce_5.png>
<p>It seems we were overfitting a little because we increased the accuracy a small amount by adding an L1 and L2 regularization penalty. What errors are still being made by the model?</p>
<p>Let’s see how the weights look after adding <code class="docutils literal notranslate"><span class="pre">L1_penalty</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">W_in</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">in_layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="c1"># we can run detach and numpy to get a numpy array</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape of W_in:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">W_in</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">W_in</span><span class="p">[:,</span><span class="n">isort</span><span class="p">],</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">5e-3</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">5e-3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;neurons&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;hidden units&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;$W_</span><span class="si">{in}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The weights appear to be sparser than before.</p>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./tutorials/W2D1_DeepLearning/student"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="../W2D1_Intro.html" title="previous page">Intro</a>
    <a class='right-next' id="next-link" href="W2D1_Tutorial2.html" title="next page">Tutorial 2: Convolutional Neural Networks</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Neuromatch<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>